1:"$Sreact.fragment"
2:I[4132,["500","static/chunks/500-3ff701859ea2af56.js","177","static/chunks/app/layout-b3b45bcae74a418e.js"],"LanguageProvider"]
3:I[5727,["500","static/chunks/500-3ff701859ea2af56.js","177","static/chunks/app/layout-b3b45bcae74a418e.js"],"default"]
4:I[7121,[],""]
5:I[4581,[],""]
6:I[5384,["500","static/chunks/500-3ff701859ea2af56.js","177","static/chunks/app/layout-b3b45bcae74a418e.js"],"default"]
8:I[484,[],"OutletBoundary"]
9:"$Sreact.suspense"
b:I[484,[],"ViewportBoundary"]
d:I[484,[],"MetadataBoundary"]
f:I[7123,[],""]
:HL["/portfolio-blog/_next/static/css/9d3bdd9f1e15d8c0.css","style"]
0:{"P":null,"b":"ciNN1PgoOFpih67RIzoK1","c":["","blog","javascript-functions",""],"q":"","i":false,"f":[[["",{"children":["blog",{"children":[["slug","javascript-functions","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],[["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/portfolio-blog/_next/static/css/9d3bdd9f1e15d8c0.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"vi","className":"scroll-smooth","children":["$","body",null,{"className":"__variable_122a3f __variable_6b04fa font-sans antialiased bg-[#f0f2f5]","children":["$","$L2",null,{"children":[["$","$L3",null,{}],["$","main",null,{"className":"min-h-screen","children":["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]}],["$","$L6",null,{}]]}]}]}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":[null,["$","$L4",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["$","$1","c",{"children":["$L7",null,["$","$L8",null,{"children":["$","$9",null,{"name":"Next.MetadataOutlet","children":"$@a"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],["$","$1","h",{"children":[null,["$","$Lb",null,{"children":"$Lc"}],["$","div",null,{"hidden":true,"children":["$","$Ld",null,{"children":["$","$9",null,{"name":"Next.Metadata","children":"$Le"}]}]}],null]}],false]],"m":"$undefined","G":["$f",[]],"S":true}
10:I[8500,["437","static/chunks/437-662f772b2654fde0.js","500","static/chunks/500-3ff701859ea2af56.js","953","static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js"],""]
11:T3d35,<h2>Hành trình từ "code spaghetti" đến modular network architecture</h2>
<p>Tôi còn nhớ như in lần đầu tiên làm việc với một dự án JavaScript có quy mô lớn. File <code>network.js</code> của tôi lên đến 1500 dòng code! Fetch calls nằm rải rác đây đó, WebSocket connections xen kẽ với business logic, error handling thì hỗn loạn khắp nơi.</p>
<p>Mỗi khi cần sửa một API endpoint, tôi phải scroll qua scroll lại trong đống code khổng lồ đó, sợ rằng thay đổi này sẽ break cái kia. Khi team thêm một developer mới, họ mất cả ngày để hiểu cấu trúc. Thêm một feature mới? Conflict code là chuyện thường xuyên.</p>
<p>Đó chính là lúc tôi nhận ra: network code không thể viết theo kiểu "tất cả trong một chỗ". Khi codebase phát triển, việc tổ chức thành modules không chỉ là "best practice" - mà là yếu tố sống còn cho sự tồn vong của dự án.</p>
<p>Trong dự án e-commerce mà tôi từng tham gia, team chúng tôi có hơn 20 API endpoints khác nhau. Ban đầu dùng single file approach, kết quả là:</p>
<ul>
<li>Bug khó track và reproduce</li>
<li>Feature conflicts liên tục</li>
<li>Testing gần như impossible</li>
<li>Onboarding developer mới mất 3-4 ngày</li>
</ul>
<p>Sau khi refactor thành modular structure, productivity tăng vọt. Mỗi module có trách nhiệm riêng biệt, testing dễ dàng, và team có thể work parallel mà không lo conflict. Đó là khoảnh khắc "aha" khiến tôi quyết định viết bài này.</p>
<p>Bạn đã bao giờ trải qua những khó khăn tương tự? Nếu có, thì bài viết này là dành cho bạn.</p>
<hr>
<h2>Tư duy tổ chức network theo modules</h2>
<p>Một cấu trúc network module thường bao gồm:</p>
<ul>
<li><strong>API Client</strong>: chịu trách nhiệm giao tiếp HTTP</li>
<li><strong>Domain-specific APIs</strong>: xử lý logic theo từng domain (users, products, etc.)</li>
<li><strong>WebSocket Manager</strong>: quản lý realtime connection</li>
<li><strong>Utilities</strong>: các hàm dùng chung như retry, debounce, error handling</li>
</ul>
<p>Cách tổ chức này giúp codebase:</p>
<ul>
<li>Clean hơn</li>
<li>Dễ test</li>
<li>Dễ tái sử dụng</li>
<li>Dễ mở rộng trong tương lai</li>
</ul>
<hr>
<h2>API Client - Nền tảng của modular network architecture</h2>
<p>API Client không chỉ là code - nó là investment cho future scalability. Trong kinh nghiệm của tôi, một API client tốt cần những yếu tố sau:</p>
<p><strong>Thứ nhất: Consistent error handling</strong>
Tôi từng gặp phải tình huống response.ok check bị miss ở một số endpoints, dẫn đến application crash. Từ đó, tôi luôn implement error handling ở layer thấp nhất.</p>
<p><strong>Thứ hai: Request/response interceptors</strong>
Authentication headers, logging, caching - tất cả nên được handle ở một chỗ. Trong dự án thực tế, tôi có interceptor để tự động refresh JWT token khi expired.</p>
<p><strong>Thứ ba: Timeout management</strong>
Network requests không thể chờ mãi mãi. Timeout giúp user experience tốt hơn và tránh blocking UI.</p>
<p><strong>Thứ tư: Retry mechanism</strong>
Network không bao giờ reliable 100%. Exponential backoff retry đã cứu tôi khỏi nhiều production issues.</p>
<p>Khi implement API client, tôi luôn nghĩ về future. API này sẽ scale như thế nào? Team sẽ dùng nó ra sao? Câu trả lời quyết định architecture decisions.</p>
<p>Trong dự án gần nhất, API client của tôi đã evolve từ simple class thành một sophisticated system với:</p>
<ul>
<li>Automatic retry với exponential backoff</li>
<li>Request queuing cho rate limiting</li>
<li>Response caching layer</li>
<li>Comprehensive logging</li>
</ul>
<p>Đầu tư thời gian build API client tốt từ đầu luôn đáng giá hơn refactor sau này.</p>
<h2>Specialized API Modules - Khi một API Client chưa đủ</h2>
<p>Sau khi có API Client, bạn sẽ nhanh chóng nhận ra: gọi client.get('/users') trực tiếp trong component không phải ý tưởng hay. Tại sao?</p>
<p>Trong dự án thực tế, user operations không chỉ là CRUD đơn thuần. Có validation, data transformation, caching, error mapping. Nếu viết tất cả trong component, code sẽ trở nên messy và hard to test.</p>
<p>Tôi đã từng thấy một component có 200+ dòng code chỉ để handle user management. Login, logout, profile update, password change - tất cả lẫn lộn với UI logic.</p>
<p>Giải pháp? Specialized API modules cho từng domain. Mỗi module handle business logic của domain đó, trong khi component chỉ cần call methods có nghĩa.</p>
<p>Trong dự án e-commerce, tôi có:</p>
<ul>
<li>UserAPI: authentication, profile management</li>
<li>ProductAPI: catalog, inventory, pricing</li>
<li>OrderAPI: checkout, payment, shipping</li>
<li>NotificationAPI: email, push notifications</li>
</ul>
<p>Cách tổ chức này mang lại:</p>
<ul>
<li><strong>Separation of concerns</strong>: Network logic tách biệt với UI</li>
<li><strong>Testability</strong>: Dễ test business logic độc lập</li>
<li><strong>Reusability</strong>: API modules dùng lại cho multiple components</li>
<li><strong>Maintainability</strong>: Thay đổi API endpoint không ảnh hưởng UI</li>
</ul>
<p>Tôi thường design API modules theo business use cases chứ không phải theo technical endpoints. Ví dụ: AuthAPI có methods như login(), logout(), refreshToken() thay vì chỉ post('/auth/login').</p>
<p>Đây là pattern đã chứng minh hiệu quả qua nhiều dự án của tôi.</p>
<h2>WebSocket Manager - Khi realtime trở thành phức tạp</h2>
<p>WebSocket ban đầu nghe có vẻ đơn giản: connect và listen. Nhưng trong production, mọi thứ phức tạp hơn nhiều.</p>
<p>Tôi từng build một chat application với WebSocket. Ban đầu chỉ là socket.onmessage đơn giản. Nhưng khi deploy production:</p>
<ul>
<li>Connection drops liên tục do network issues</li>
<li>Server restart khiến tất cả clients disconnect</li>
<li>Message ordering bị mess up</li>
<li>Memory leaks từ event listeners</li>
<li>No error handling khi connection failed</li>
</ul>
<p>Đó là lúc tôi nhận ra: WebSocket cần một manager layer. Một system để handle:</p>
<p><strong>Connection management</strong></p>
<ul>
<li>Auto reconnect với exponential backoff</li>
<li>Connection pooling cho high-traffic apps</li>
<li>Health checks và heartbeat</li>
</ul>
<p><strong>Message handling</strong></p>
<ul>
<li>Message queuing khi disconnected</li>
<li>Duplicate message detection</li>
<li>Message ordering guarantees</li>
</ul>
<p><strong>Error handling</strong></p>
<ul>
<li>Network timeouts</li>
<li>Server errors</li>
<li>Invalid message formats</li>
</ul>
<p><strong>Lifecycle management</strong></p>
<ul>
<li>Clean up connections khi component unmount</li>
<li>Memory leak prevention</li>
<li>Resource pooling</li>
</ul>
<p>Trong dự án chat app, WebSocket Manager của tôi đã evolve thành một sophisticated system:</p>
<ul>
<li>Auto reconnect với smart backoff</li>
<li>Message deduplication</li>
<li>Typing indicators</li>
<li>Online/offline status</li>
<li>File transfer over WebSocket</li>
</ul>
<p>Nếu bạn đang làm realtime features, đừng under-estimate complexity. WebSocket Manager là investment đáng giá cho long-term maintainability.</p>
<h2>Network Utility Functions - Những helper không thể thiếu</h2>
<p>Khi làm việc với network requests, bạn sẽ thấy mình lặp lại một số patterns. Đó là lúc cần utility functions.</p>
<p><strong>Retry logic - Khi network không reliable</strong>
Tôi từng có production bug vì API call failed một lần duy nhất do temporary network issue. User refresh page, mọi thứ work normally. Từ đó, tôi implement retry cho tất cả critical requests.</p>
<p>Exponential backoff quan trọng: không retry immediately để tránh overload server. Start với 1s, 2s, 4s, 8s...</p>
<p><strong>Debounce - Performance savior cho search inputs</strong>
Trong e-commerce project, search API được call mỗi lần user type. Without debounce, có thể có 10-20 requests trong 1 giây. Debounce giúp reduce API calls và improve performance.</p>
<p><strong>Request deduplication - Tránh duplicate requests</strong>
Trong một dashboard app, tôi có bug khi user click button multiple times, tạo ra duplicate orders. Request deduplication đã solve vấn đề này.</p>
<p><strong>Caching utilities - Reduce server load</strong>
Cache responses locally để tránh call API không cần thiết. Nhưng cần cache invalidation strategy.</p>
<p>Trong thực tế, tôi build một utility library với:</p>
<ul>
<li>Smart retry với circuit breaker</li>
<li>Request deduplication</li>
<li>Response caching với TTL</li>
<li>Rate limiting</li>
<li>Request batching</li>
</ul>
<p>Những utilities này đã prevent nhiều production issues và improve user experience đáng kể.</p>
<h2>Khi tất cả modules hòa quyện</h2>
<p>Sau khi build từng module riêng biệt, việc integrate chúng lại thành một cohesive system cũng là nghệ thuật.</p>
<p>Trong dự án lớn, tôi có một composition root - nơi assemble tất cả dependencies:</p>
<pre><code class="language-javascript">// composition root
const apiClient = new APIClient(BASE_URL);
const userAPI = new UserAPI(apiClient);
const productAPI = new ProductAPI(apiClient);
const wsManager = new WebSocketManager(WS_URL);

export { userAPI, productAPI, wsManager };
</code></pre>
<p>Cách này giúp:</p>
<ul>
<li>Clear dependency flow</li>
<li>Easy testing với mocks</li>
<li>Flexible configuration cho different environments</li>
</ul>
<h2>Centralized Error Handling - Khi mọi thứ có thể fail</h2>
<p>Error handling là phần bị under-estimate nhất trong network programming. Nhưng trong production, mọi thứ đều có thể fail: network, server, authentication, rate limits...</p>
<p>Tôi từng ship một app mà không có proper error handling. Kết quả:</p>
<ul>
<li>White screen khi API down</li>
<li>Confusing error messages</li>
<li>User không biết phải làm gì</li>
<li>Support tickets tăng vọt</li>
</ul>
<p>Từ đó, tôi implement centralized error handling system. Mọi network error đi qua một pipeline:</p>
<p><strong>Error classification</strong></p>
<ul>
<li>Network errors (connection, timeout)</li>
<li>Server errors (500, 502, 503)</li>
<li>Client errors (400, 401, 403, 404)</li>
<li>Authentication errors (token expired)</li>
</ul>
<p><strong>User-friendly messages</strong>
Không phải developer messages. User cần biết: "Connection lost, please check internet" thay vì "TypeError: Failed to fetch"</p>
<p><strong>Recovery strategies</strong></p>
<ul>
<li>Auto retry cho transient errors</li>
<li>Redirect to login khi 401</li>
<li>Show offline mode khi network down</li>
<li>Graceful degradation</li>
</ul>
<p><strong>Logging and monitoring</strong></p>
<ul>
<li>Error tracking để improve system</li>
<li>Alert khi error rate cao</li>
<li>Debug information cho developers</li>
</ul>
<p>Trong dự án fintech, error handling đã prevent nhiều potential issues. User thấy meaningful messages thay vì crashes, và team có insights để improve system reliability.</p>
<h2>Bài học từ kinh nghiệm refactor - Những gì tôi đã học được</h2>
<p>Refactor codebase từ monolithic network.js sang modular architecture là một trong những best decisions tôi từng làm. Nhưng cũng là challenging nhất.</p>
<p><strong>Thứ nhất: Start small, think big</strong>
Tôi bắt đầu với API Client duy nhất. Khi nó prove value, tôi expand dần. Don't try to modularize everything cùng lúc - bạn sẽ tạo ra mess lớn hơn.</p>
<p><strong>Thứ hai: Invest in testing từ đầu</strong>
Modular code dễ test, nhưng bạn phải test. Tôi từng skip testing vì "code đơn giản". Kết quả là production bugs. Bây giờ tôi test mọi module: unit tests, integration tests, e2e tests.</p>
<p><strong>Thứ ba: Documentation matters</strong>
Khi code trở nên modular, documentation trở thành critical. Team members cần hiểu purpose của mỗi module, dependencies, và cách sử dụng.</p>
<p><strong>Thứ tư: Monitor and iterate</strong>
Sau refactor, tôi track metrics: error rates, response times, development velocity. Modular architecture nên improve tất cả những metrics này.</p>
<p><strong>Thứ năm: Cultural change</strong>
Modular thinking là mindset change. Team cần buy-in vào approach này. Code reviews, knowledge sharing sessions đều quan trọng.</p>
<p>Trong dự án gần nhất, refactor này đã:</p>
<ul>
<li>Giảm 60% error rates</li>
<li>Tăng 40% development speed</li>
<li>Improve code quality đáng kể</li>
<li>Make onboarding developers dễ dàng hơn</li>
</ul>
<p>Modular architecture không chỉ là code organization - nó là foundation cho scalable development culture.</p>
<h2>Kết luận: JavaScript Modules - Nền tảng của ứng dụng scalable</h2>
<p>Quay lại câu hỏi đầu bài: "Làm thế nào để tổ chức code network một cách có cấu trúc?" - JavaScript Modules chính là câu trả lời toàn diện và hiện đại nhất.</p>
<p><strong>Tóm tắt hành trình chúng ta đã đi qua:</strong></p>
<ol>
<li><strong>Spaghetti code problems</strong> - Những hậu quả thực tế của monolithic network code</li>
<li><strong>API Client foundation</strong> - Investment cho future scalability</li>
<li><strong>Domain-specific modules</strong> - Business logic separation và testability</li>
<li><strong>WebSocket complexity</strong> - Managing realtime connections trong production</li>
<li><strong>Utility functions</strong> - Preventing common network issues</li>
<li><strong>Error handling systems</strong> - User experience và system reliability</li>
<li><strong>Refactor lessons</strong> - Từ failures đến best practices</li>
</ol>
<p><strong>Lộ trình tiếp theo cho bạn:</strong></p>
<ul>
<li>Học về State Management (Redux, Zustand)</li>
<li>Implement Testing cho modules (Jest, React Testing Library)</li>
<li>Tìm hiểu Design Patterns trong JavaScript</li>
<li>Xây dựng full-stack applications</li>
<li>Học về Code Bundling và Optimization</li>
</ul>
<p>JavaScript Modules đã thay đổi hoàn toàn cách tôi tổ chức code. Từ việc viết monolithic scripts, giờ tôi có thể build maintainable, scalable applications với confidence.</p>
<p><strong>Bạn sẽ bắt đầu transformation từ đâu?</strong></p>
<ul>
<li>Nếu đang struggle với legacy code: Start với một API Client module</li>
<li>Nếu làm dự án mới: Implement modular structure từ đầu</li>
<li>Nếu team lead: Educate team về benefits của modular thinking</li>
</ul>
<p>Nếu bạn thấy bài viết hữu ích, hãy share cho bạn bè cùng học nhé! Chúc bạn code vui vẻ và thành công với JavaScript development!</p>
<p><em>P.S: Bài viết này là phần cuối trong series "JavaScript Network Programming". Hẹn gặp bạn ở series tiếp theo về React/Next.js và modern web development!</em></p>
7:["$","div",null,{"className":"pt-16 min-h-screen bg-[#f0f2f5]","children":["$","div",null,{"className":"max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12","children":[["$","$L10",null,{"href":"/blog","className":"inline-flex items-center gap-2 text-[#b16cea] hover:text-[#ff5e69] mb-8 transition-colors font-medium","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left w-5 h-5","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],["$","span",null,{"children":"Quay lại Blog"}]]}],["$","div",null,{"className":"bg-white rounded-xl shadow-sm border border-gray-200 p-8 md:p-12 mb-8","children":[["$","h1",null,{"className":"text-3xl md:text-5xl font-bold text-[#161513] mb-4 leading-tight","children":"JavaScript Network Module Patterns"}],["$","p",null,{"className":"text-lg text-gray-600 leading-relaxed mb-6","children":"Tìm hiểu cách tổ chức code network với JavaScript modules: xây dựng API client, WebSocket manager và các utility giúp codebase dễ bảo trì và mở rộng."}],["$","div",null,{"className":"flex items-center justify-between flex-wrap gap-4","children":[["$","div",null,{"className":"flex flex-wrap gap-2","children":[["$","span","JavaScript",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"JavaScript"}],["$","span","Modules",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"Modules"}],["$","span","Network Programming",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"Network Programming"}],["$","span","Code Organization",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"Code Organization"}],["$","span","API Client",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"API Client"}]]}],["$","span",null,{"className":"text-sm text-gray-500 whitespace-nowrap","style":{"fontFamily":"var(--font-inter)"},"children":"2024-04-30"}]]}]]}],["$","article",null,{"className":"mb-12","children":["$","div",null,{"className":"prose prose-lg max-w-none prose-headings:text-[#161513] prose-p:text-[#374151] prose-p:leading-relaxed prose-a:text-[#b16cea] prose-a:no-underline hover:prose-a:underline prose-strong:text-[#161513] prose-code:text-[#b16cea] prose-code:bg-gray-100 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-pre:bg-[#1f2937] prose-pre:rounded-lg prose-h2:text-2xl prose-h2:font-bold prose-h2:mt-12 prose-h2:mb-6 prose-h3:text-xl prose-h3:font-semibold prose-h3:mt-8 prose-h3:mb-4","dangerouslySetInnerHTML":{"__html":"$11"}}]}],"$L12","$L13"]}]}]
14:I[8437,["437","static/chunks/437-662f772b2654fde0.js","500","static/chunks/500-3ff701859ea2af56.js","953","static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js"],"Image"]
15:I[8846,["437","static/chunks/437-662f772b2654fde0.js","500","static/chunks/500-3ff701859ea2af56.js","953","static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js"],"default"]
12:["$","div",null,{"className":"bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8","children":["$","div",null,{"className":"flex items-center justify-between flex-wrap gap-6","children":[["$","div",null,{"className":"flex items-center gap-4","children":[["$","div",null,{"className":"relative w-16 h-16 rounded-full overflow-hidden bg-gradient-to-br from-indigo-400 to-purple-500 flex-shrink-0","children":["$","$L14",null,{"src":"/images/avatar/avatar.png","alt":"Truong Yen Phuong","fill":true,"className":"object-cover"}]}],["$","div",null,{"children":[["$","h3",null,{"className":"font-semibold text-[#161513] text-lg mb-1","children":"Truong Yen Phuong"}],["$","p",null,{"className":"text-sm text-gray-600","children":"Tổng hợp kinh nghiệm"}]]}]]}],["$","div",null,{"className":"flex items-center gap-4 flex-wrap","children":[["$","div",null,{"className":"flex items-center gap-2","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-share2 lucide-share-2 w-5 h-5 text-[#b16cea]","aria-hidden":"true","children":[["$","circle","gq8acd",{"cx":"18","cy":"5","r":"3"}],["$","circle","w7nqdw",{"cx":"6","cy":"12","r":"3"}],["$","circle","1xt0gg",{"cx":"18","cy":"19","r":"3"}],["$","line","47mynk",{"x1":"8.59","x2":"15.42","y1":"13.51","y2":"17.49"}],["$","line","1n3mei",{"x1":"15.41","x2":"8.59","y1":"6.51","y2":"10.49"}],"$undefined"]}],["$","span",null,{"className":"font-semibold text-[#161513]","children":"Chia sẻ bài viết:"}]]}],["$","$L15",null,{"title":"JavaScript Network Module Patterns","slug":"javascript-functions"}]]}]]}]}]
13:["$","div",null,{"className":"text-center","children":["$","$L10",null,{"href":"/blog","className":"inline-flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-[#b16cea] to-[#ff5e69] text-white rounded-lg font-semibold hover:opacity-90 transition-opacity","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left w-5 h-5","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"Xem tất cả bài viết"]}]}]
c:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
16:I[6869,[],"IconMark"]
a:null
e:[["$","title","0",{"children":"JavaScript Network Module Patterns - Blog"}],["$","meta","1",{"name":"description","content":"Tìm hiểu cách tổ chức code network với JavaScript modules: xây dựng API client, WebSocket manager và các utility giúp codebase dễ bảo trì và mở rộng."}],["$","meta","2",{"name":"author","content":"Fang"}],["$","meta","3",{"name":"keywords","content":"Frontend Developer,UI/UX Designer,React,Next.js,JavaScript,Java,Portfolio"}],["$","meta","4",{"property":"og:title","content":"Truong Yen Phuong | Portfolio"}],["$","meta","5",{"property":"og:description","content":"Portfolio và Blog cá nhân về Frontend Development và UI/UX Design"}],["$","meta","6",{"property":"og:type","content":"website"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"Truong Yen Phuong | Portfolio"}],["$","meta","9",{"name":"twitter:description","content":"Portfolio và Blog cá nhân về Frontend Development và UI/UX Design"}],["$","link","10",{"rel":"icon","href":"/portfolio-blog/favicon.ico?9e65197c8e8dbd7e","type":"image/x-icon","sizes":"454x454"}],["$","$L16","11",{}]]
