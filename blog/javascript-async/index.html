<!DOCTYPE html><!--ciNN1PgoOFpih67RIzoK1--><html lang="vi" class="scroll-smooth"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/portfolio-blog/_next/static/css/9d3bdd9f1e15d8c0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/portfolio-blog/_next/static/chunks/webpack-76edfa5e208bca6c.js"/><script src="/portfolio-blog/_next/static/chunks/4bd1b696-67e30520d621c4dd.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/794-2191c34f3e713f20.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/main-app-f6647a60c79a7108.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/500-3ff701859ea2af56.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/app/layout-b3b45bcae74a418e.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/437-662f772b2654fde0.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js" async=""></script><title>JavaScript Async Network Operations - Blog</title><meta name="description" content="Tìm hiểu về xử lý bất đồng bộ trong network programming với async/await, Promises, và các kỹ thuật xử lý nhiều network operations đồng thời."/><meta name="author" content="Fang"/><meta name="keywords" content="Frontend Developer,UI/UX Designer,React,Next.js,JavaScript,Java,Portfolio"/><meta property="og:title" content="Truong Yen Phuong | Portfolio"/><meta property="og:description" content="Portfolio và Blog cá nhân về Frontend Development và UI/UX Design"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Truong Yen Phuong | Portfolio"/><meta name="twitter:description" content="Portfolio và Blog cá nhân về Frontend Development và UI/UX Design"/><link rel="icon" href="/portfolio-blog/favicon.ico?9e65197c8e8dbd7e" type="image/x-icon" sizes="454x454"/><script src="/portfolio-blog/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_122a3f __variable_6b04fa font-sans antialiased bg-[#f0f2f5]"><div hidden=""><!--$--><!--/$--></div><nav class="fixed z-50 transition-all duration-700 ease-out top-0 left-0 right-0 rounded-none bg-[#f0f2f5]/95 backdrop-blur-xl border-b" style="border-color:var(--color--transparent)"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="relative flex justify-between items-center h-16 transition-all duration-700"><div class="flex items-center"><a class="hover:opacity-80 transition-opacity duration-300" href="/portfolio-blog/"><span class="text-[28px] font-bold text-[#161513]">Fang.</span></a></div><div class="hidden md:flex items-center space-x-6 absolute left-1/2 transform -translate-x-1/2"><a class="px-3 py-2 text-base font-medium transition-all duration-300 text-[#161513] hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent" href="/portfolio-blog/">Trang chủ</a><a class="px-3 py-2 text-base font-medium transition-all duration-300 text-[#161513] hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent" href="/portfolio-blog/certificates/">Chứng chỉ</a><a class="px-3 py-2 text-base font-medium transition-all duration-300 bg-gradient-to-r from-[#b16cea] via-[#ff5e69] via-[#ff8a56] to-[#ffa84b] bg-clip-text text-transparent" href="/portfolio-blog/blog/">Bài viết</a><a class="px-3 py-2 text-base font-medium transition-all duration-300 text-[#161513] hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent" href="/portfolio-blog/about/">Giới thiệu</a></div><div class="flex items-center space-x-4"><div class="hidden md:block"><div class="relative overflow-hidden bg-[#161513] rounded-full group"><a class="relative block text-[#f0f2f5] px-5 py-2.5 text-sm font-medium transition-colors duration-300 group-hover:text-white z-10" href="/portfolio-blog/contact/">Liên hệ</a><div class="absolute inset-0 bg-gradient-to-r from-[#b16cea] via-[#ff5e69] via-[#ff8a56] to-[#ffa84b] transform -translate-x-full group-hover:translate-x-0 transition-transform duration-500 ease-out pointer-events-none"></div></div></div><div class="hidden md:block ml-2"><div class="flex items-center gap-2 text-sm font-medium"><button class="transition-all duration-300 text-[#161513]">VI</button><div class="w-px h-4 bg-gray-300"></div><button class="transition-all duration-300 text-gray-400 hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent">EN</button></div></div><button class="md:hidden p-2 rounded-md text-gray-700 hover:bg-gray-100 transition-colors duration-300" aria-label="Toggle menu"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></div></nav><main class="min-h-screen"><div class="pt-16 min-h-screen bg-[#f0f2f5]"><div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12"><a class="inline-flex items-center gap-2 text-[#b16cea] hover:text-[#ff5e69] mb-8 transition-colors font-medium" href="/portfolio-blog/blog/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left w-5 h-5" aria-hidden="true"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg><span>Quay lại Blog</span></a><div class="bg-white rounded-xl shadow-sm border border-gray-200 p-8 md:p-12 mb-8"><h1 class="text-3xl md:text-5xl font-bold text-[#161513] mb-4 leading-tight">JavaScript Async Network Operations</h1><p class="text-lg text-gray-600 leading-relaxed mb-6">Tìm hiểu về xử lý bất đồng bộ trong network programming với async/await, Promises, và các kỹ thuật xử lý nhiều network operations đồng thời.</p><div class="flex items-center justify-between flex-wrap gap-4"><div class="flex flex-wrap gap-2"><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">JavaScript</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Async</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Await</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Promises</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Network Programming</span></div><span class="text-sm text-gray-500 whitespace-nowrap" style="font-family:var(--font-inter)">2024-04-20</span></div></div><article class="mb-12"><div class="prose prose-lg max-w-none prose-headings:text-[#161513] prose-p:text-[#374151] prose-p:leading-relaxed prose-a:text-[#b16cea] prose-a:no-underline hover:prose-a:underline prose-strong:text-[#161513] prose-code:text-[#b16cea] prose-code:bg-gray-100 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-pre:bg-[#1f2937] prose-pre:rounded-lg prose-h2:text-2xl prose-h2:font-bold prose-h2:mt-12 prose-h2:mb-6 prose-h3:text-xl prose-h3:font-semibold prose-h3:mt-8 prose-h3:mb-4"><h2>Vấn đề callback hell trong network programming</h2>
<p>Bạn đã bao giờ thấy code JavaScript với vô số nested callbacks? Đó là callback hell - khi network operations tạo thành một kim tự tháp khó maintain.</p>
<pre><code class="language-javascript">// Callback hell - khó đọc, khó debug
fetch('/api/user', (user) => {
  fetch(`/api/posts/${user.id}`, (posts) => {
    fetch(`/api/comments/${posts[0].id}`, (comments) => {
      // Còn nữa...
    });
  });
});
</code></pre>
<p>JavaScript evolution từ callbacks → Promises → async/await để giải quyết vấn đề này. Async programming giờ trở nên tự nhiên và dễ hiểu.</p>
<h2>Promises - Khi mình bắt đầu học async</h2>
<p>Lúc đầu học JavaScript, mình nghe khái niệm Promise mà confuse lắm. "Promise là cái gì? Tại sao lại có pending, fulfilled, rejected?" Mình đã dành cả buổi tối để đọc docs về Promise, nhưng vẫn mò mẫm.</p>
<p>Rồi mình hiểu ra: Promise là một "lời hứa" - bạn request cái gì đó, và Promise hứa sẽ trả về kết quả trong tương lai. Với network requests, fetch() trả về Promise ngay lập tức, nhưng data thì chưa có.</p>
<p>Mình nhớ lần đầu tiên dùng Promise thành công. Thay vì callback hell, mình có thể chain các .then() lại với nhau. Đơn giản hơn nhiều!</p>
<pre><code class="language-javascript">// Promise đầu tiên của mình
fetch('/api/user')
  .then(response => response.json())
  .then(user => {
    console.log('Được rồi! User:', user);
    return fetch(`/api/posts/${user.id}`);
  })
  .then(response => response.json())
  .then(posts => {
    console.log('Posts cũng có rồi:', posts);
  })
  .catch(error => {
    console.error('Ối, lỗi rồi:', error);
  });
</code></pre>
<h3>Async/Await - "Aha moment" của mình</h3>
<p>Rồi một ngày, mình học được async/await. Wow! Code bất đồng bộ giờ trông giống synchronous code hẳn. Mình đã refactor toàn bộ project cá nhân từ Promise chains sang async/await.</p>
<p>Điều làm mình ấn tượng nhất là error handling. Try/catch blocks giờ hoạt động bình thường với async code. Không còn .catch() chains phức tạp nữa.</p>
<pre><code class="language-javascript">async function layDuLieu() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log('Dữ liệu đây:', data);
    return data;
  } catch (error) {
    console.error('Lỗi rồi bạn ơi:', error);
    throw error;
  }
}
</code></pre>
<p>Mình đã dành 2 tuần để chuyển đổi toàn bộ codebase. Ban đầu confusing lắm, nhưng giờ nhìn lại, code clean hẳn ra!</p>
<h3>Xử lý nhiều requests - Bài toán khó nhất của mình</h3>
<p>Lúc đầu, mình nghĩ fetch một API là đủ rồi. Nhưng khi làm project thực tế, mình cần fetch nhiều APIs cùng lúc. Đó là lúc mình học được Promise.all.</p>
<p><strong>Promise.all - Chờ tất cả hoàn thành</strong>
Mình có app cần load 5 users cùng lúc. Thay vì fetch tuần tự (chậm), mình dùng Promise.all để fetch song song. Performance tăng vọt!</p>
<pre><code class="language-javascript">async function layNhieuUsers(userIds) {
  try {
    const promises = userIds.map(id =>
      fetch(`https://api.example.com/users/${id}`)
        .then(res => res.json())
    );

    const users = await Promise.all(promises);
    console.log('Tất cả users:', users);
    return users;
  } catch (error) {
    console.error('Có lỗi xảy ra:', error);
  }
}
</code></pre>
<p><strong>Promise.race - Timeout cho requests</strong>
Network không đáng tin cậy. Mình đã từng có request treo cả phút. Promise.race cứu cánh đấy!</p>
<pre><code class="language-javascript">async function fetchVoiTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Timeout!')), timeout)
  );

  try {
    const response = await Promise.race([fetchPromise, timeoutPromise]);
    return await response.json();
  } catch (error) {
    console.log('Request timeout hoặc lỗi:', error.message);
  }
}
</code></pre>
<p>Mình đã áp dụng timeout cho tất cả API calls sau bài học đắt giá đó.</p>
<h3>Retry logic - Khi network "làm biếng"</h3>
<p>Network programming dạy mình rằng: thất bại là bình thường. Server có thể down, connection có thể đứt. Mình đã có project fail vì không handle retry properly.</p>
<p><strong>Bài học từ kinh nghiệm:</strong>
Mình đã implement retry với exponential backoff. Lần đầu fail, thử lại sau 1s. Lần thứ 2 fail, thử lại sau 2s. Lần thứ 3 fail, thử lại sau 4s. Thông minh đúng không?</p>
<pre><code class="language-javascript">async function fetchVoiRetry(url, maxRetries = 3) {
  let delay = 1000;

  for (let lanThu = 0; lanThu &#x3C; maxRetries; lanThu++) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        return await response.json();
      }
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (lanThu === maxRetries - 1) {
        throw error; // Đã thử hết rồi
      }
      console.log(`Lần ${lanThu + 1} fail, thử lại sau ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // Tăng delay
    }
  }
}
</code></pre>
<h3>Sequential vs Parallel - Performance matters</h3>
<p>Lúc đầu, mình viết code tuần tự (sequential) vì dễ hiểu. Nhưng khi có 10 requests, mất 10 giây thay vì 1 giây. Đó là lúc mình học parallel processing.</p>
<p><strong>Sequential (chậm):</strong></p>
<pre><code class="language-javascript">async function layTuTu(userIds) {
  const users = [];
  for (const id of userIds) {
    const response = await fetch(`https://api.example.com/users/${id}`);
    const user = await response.json();
    users.push(user);
  }
  return users;
}
</code></pre>
<p><strong>Parallel (nhanh):</strong></p>
<pre><code class="language-javascript">async function laySongSong(userIds) {
  const promises = userIds.map(id =>
    fetch(`https://api.example.com/users/${id}`)
      .then(res => res.json())
  );
  return await Promise.all(promises);
}
</code></pre>
<p>Mình đã tối ưu performance project của mình từ 8 giây xuống 2 giây chỉ bằng cách này!</p>
<h3>Error handling - Bài học đắt giá</h3>
<p>Lúc đầu, mình nghĩ error handling là optional. "Code chạy được là được rồi!" Nhưng production dạy mình bài học đắt giá.</p>
<p>Mình đã có lần app crash vì không handle network errors properly. Users thấy white screen, support tickets đổ về như mưa. Từ đó, mình implement comprehensive error handling.</p>
<p><strong>Global error handler:</strong>
Mình tạo một wrapper cho tất cả fetch calls. Log error, show user-friendly message, và report to monitoring service.</p>
<p><strong>Cancellation - Khi user không chờ nữa:</strong>
Trong app chat của mình, khi user chuyển trang, mình cần cancel pending requests. AbortController cứu cánh đấy!</p>
<pre><code class="language-javascript">class FetchCoTheHuy {
  constructor(url) {
    this.controller = new AbortController();
    this.signal = this.controller.signal;
    this.promise = fetch(url, { signal: this.signal });
  }

  cancel() {
    this.controller.abort();
  }

  async get() {
    try {
      const response = await this.promise;
      return await response.json();
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('User đã cancel request');
        return null;
      }
      throw error;
    }
  }
}
</code></pre>
<p>Mình đã prevent nhiều memory leaks nhờ cancellation pattern này.</p>
<h2>Những gì mình học được sau nhiều tháng vật lộn với async</h2>
<p>Sau khi hoàn thành môn JavaScript nâng cao, mình có thể tự tin nói: async programming đã thay đổi cách mình code forever.</p>
<p><strong>Thứ nhất: Từ confuse đến master</strong>
Lúc đầu, Promise, async/await làm mình đau đầu. Nhưng khi hiểu được, mọi thứ trở nên logical. Mình có thể handle complex async flows dễ dàng.</p>
<p><strong>Thứ hai: Performance optimization thực tế</strong>
Mình đã tối ưu project từ 8 giây load time xuống 2 giây chỉ bằng Promise.all. Đó là khoảnh khắc "wow" khi thấy code thực sự matters.</p>
<p><strong>Thứ ba: Error handling is everything</strong>
Network unreliable lắm. Retry logic, timeout, cancellation - những concepts này giờ thành reflex của mình.</p>
<p><strong>Thứ tư: Code quality improvement</strong>
Async/await làm code readable hơn hẳn. Teammates có thể hiểu và maintain dễ dàng. Testing cũng đơn giản hơn nhiều.</p>
<h2>Kết luận: Async programming - Journey của một sinh viên</h2>
<p>Async/await không chỉ là syntax - mà là mindset shift. Từ việc sợ asynchronous code, giờ mình có thể build scalable network applications.</p>
<p>Nếu bạn đang học JavaScript và thấy async confusing, đừng nản nhé! Mình cũng từng như bạn. Hãy bắt đầu với simple Promise, rồi dần dần lên async/await. Practice nhiều, debug nhiều, và bạn sẽ conquer được.</p>
<p><strong>Lời khuyên cho sinh viên:</strong></p>
<ul>
<li>Bắt đầu với Promise chains trước khi nhảy vào async/await</li>
<li>Practice với nhiều network requests để hiểu performance</li>
<li>Implement error handling từ early stage</li>
<li>Đừng ngại refactor - từ callbacks sang async/await đáng effort lắm</li>
</ul>
<p>Nếu bài này giúp ích được gì, hãy share cho bạn bè cùng lớp nhé! Async programming khó nhưng khi conquer được, bạn sẽ thấy nó amazing lắm.</p>
<p><em>P.S: Đây là kinh nghiệm học tập của mình. Nếu bạn thấy bài viết hữu ích, hãy share cho bạn bè cùng học nhé!</em></p>
</div></article><div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8"><div class="flex items-center justify-between flex-wrap gap-6"><div class="flex items-center gap-4"><div class="relative w-16 h-16 rounded-full overflow-hidden bg-gradient-to-br from-indigo-400 to-purple-500 flex-shrink-0"><img alt="Truong Yen Phuong" loading="lazy" decoding="async" data-nimg="fill" class="object-cover" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="/images/avatar/avatar.png"/></div><div><h3 class="font-semibold text-[#161513] text-lg mb-1">Truong Yen Phuong</h3><p class="text-sm text-gray-600">Tổng hợp kinh nghiệm</p></div></div><div class="flex items-center gap-4 flex-wrap"><div class="flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share2 lucide-share-2 w-5 h-5 text-[#b16cea]" aria-hidden="true"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" x2="15.42" y1="13.51" y2="17.49"></line><line x1="15.41" x2="8.59" y1="6.51" y2="10.49"></line></svg><span class="font-semibold text-[#161513]">Chia sẻ bài viết:</span></div><div class="flex items-center gap-2"><button type="button" class="social-link w-inline-block gradient" aria-label="Share on Facebook"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-facebook w-5 h-5" aria-hidden="true"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></div></div></button><button type="button" class="social-link w-inline-block gradient" aria-label="Share on X"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg></div></div></button><button type="button" class="social-link w-inline-block gradient" aria-label="Share on LinkedIn"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin w-5 h-5" aria-hidden="true"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></div></div></button><button type="button" class="social-link w-inline-block gradient" aria-label="Copy link"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy w-5 h-5" aria-hidden="true"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></div></div></button></div></div></div></div><div class="text-center"><a class="inline-flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-[#b16cea] to-[#ff5e69] text-white rounded-lg font-semibold hover:opacity-90 transition-opacity" href="/portfolio-blog/blog/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left w-5 h-5" aria-hidden="true"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg>Xem tất cả bài viết</a></div></div></div><!--$--><!--/$--></main><footer class="footer bg-[#f0f2f5]"><div class="w-layout-blockcontainer container w-container"><div class="divider" style="background-color:rgb(22, 21, 19)"></div><div class="footer-wrap"><div class="flex footer-left"><a class="brand-logo " href="/portfolio-blog/"><span class="text-[30px] font-bold text-[#161513]">Fang.</span></a><div class="copyright dark" style="color:rgb(22, 21, 19)">© 2025 Designed by Truong Yen Phuong</div></div><div class="flex footer-right"><div class="nav-link-wrap"><a class="nav-link footer-link " style="color:rgb(22, 21, 19)" href="/portfolio-blog/">Trang chủ</a><a class="nav-link footer-link " style="color:rgb(22, 21, 19)" href="/portfolio-blog/certificates/">Chứng chỉ</a><a class="nav-link footer-link w--current" style="color:rgb(22, 21, 19)" href="/portfolio-blog/blog/">Bài viết</a><a class="nav-link footer-link " style="color:rgb(22, 21, 19)" href="/portfolio-blog/about/">Giới thiệu</a></div><div class="social-link-wrap"><a href="https://github.com/Pt-14" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a href="https://www.linkedin.com/in/phuong-truong-yen-894359371/" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg></div></div></a><a href="https://x.com/itsnongfang" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg></div></div></a><a href="https://www.facebook.com/phuong.yentruon" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"></path></svg></div></div></a><a href="https://www.instagram.com/heaven__fang/" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"></path></svg></div></div></a></div></div></div></div></footer><script src="/portfolio-blog/_next/static/chunks/webpack-76edfa5e208bca6c.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[4132,[\"500\",\"static/chunks/500-3ff701859ea2af56.js\",\"177\",\"static/chunks/app/layout-b3b45bcae74a418e.js\"],\"LanguageProvider\"]\n3:I[5727,[\"500\",\"static/chunks/500-3ff701859ea2af56.js\",\"177\",\"static/chunks/app/layout-b3b45bcae74a418e.js\"],\"default\"]\n4:I[7121,[],\"\"]\n5:I[4581,[],\"\"]\n6:I[5384,[\"500\",\"static/chunks/500-3ff701859ea2af56.js\",\"177\",\"static/chunks/app/layout-b3b45bcae74a418e.js\"],\"default\"]\n8:I[484,[],\"OutletBoundary\"]\n9:\"$Sreact.suspense\"\nb:I[484,[],\"ViewportBoundary\"]\nd:I[484,[],\"MetadataBoundary\"]\nf:I[7123,[],\"\"]\n:HL[\"/portfolio-blog/_next/static/css/9d3bdd9f1e15d8c0.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ciNN1PgoOFpih67RIzoK1\",\"c\":[\"\",\"blog\",\"javascript-async\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"javascript-async\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/portfolio-blog/_next/static/css/9d3bdd9f1e15d8c0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"vi\",\"className\":\"scroll-smooth\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_122a3f __variable_6b04fa font-sans antialiased bg-[#f0f2f5]\",\"children\":[\"$\",\"$L2\",null,{\"children\":[[\"$\",\"$L3\",null,{}],[\"$\",\"main\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$L6\",null,{}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",null,[\"$\",\"$L8\",null,{\"children\":[\"$\",\"$9\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@a\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"$9\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Le\"}]}]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:I[8500,[\"437\",\"static/chunks/437-662f772b2654fde0.js\",\"500\",\"static/chunks/500-3ff701859ea2af56.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js\"],\"\"]\n11:T284c,"])</script><script>self.__next_f.push([1,"\u003ch2\u003eVấn đề callback hell trong network programming\u003c/h2\u003e\n\u003cp\u003eBạn đã bao giờ thấy code JavaScript với vô số nested callbacks? Đó là callback hell - khi network operations tạo thành một kim tự tháp khó maintain.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Callback hell - khó đọc, khó debug\nfetch('/api/user', (user) =\u003e {\n  fetch(`/api/posts/${user.id}`, (posts) =\u003e {\n    fetch(`/api/comments/${posts[0].id}`, (comments) =\u003e {\n      // Còn nữa...\n    });\n  });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJavaScript evolution từ callbacks → Promises → async/await để giải quyết vấn đề này. Async programming giờ trở nên tự nhiên và dễ hiểu.\u003c/p\u003e\n\u003ch2\u003ePromises - Khi mình bắt đầu học async\u003c/h2\u003e\n\u003cp\u003eLúc đầu học JavaScript, mình nghe khái niệm Promise mà confuse lắm. \"Promise là cái gì? Tại sao lại có pending, fulfilled, rejected?\" Mình đã dành cả buổi tối để đọc docs về Promise, nhưng vẫn mò mẫm.\u003c/p\u003e\n\u003cp\u003eRồi mình hiểu ra: Promise là một \"lời hứa\" - bạn request cái gì đó, và Promise hứa sẽ trả về kết quả trong tương lai. Với network requests, fetch() trả về Promise ngay lập tức, nhưng data thì chưa có.\u003c/p\u003e\n\u003cp\u003eMình nhớ lần đầu tiên dùng Promise thành công. Thay vì callback hell, mình có thể chain các .then() lại với nhau. Đơn giản hơn nhiều!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Promise đầu tiên của mình\nfetch('/api/user')\n  .then(response =\u003e response.json())\n  .then(user =\u003e {\n    console.log('Được rồi! User:', user);\n    return fetch(`/api/posts/${user.id}`);\n  })\n  .then(response =\u003e response.json())\n  .then(posts =\u003e {\n    console.log('Posts cũng có rồi:', posts);\n  })\n  .catch(error =\u003e {\n    console.error('Ối, lỗi rồi:', error);\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eAsync/Await - \"Aha moment\" của mình\u003c/h3\u003e\n\u003cp\u003eRồi một ngày, mình học được async/await. Wow! Code bất đồng bộ giờ trông giống synchronous code hẳn. Mình đã refactor toàn bộ project cá nhân từ Promise chains sang async/await.\u003c/p\u003e\n\u003cp\u003eĐiều làm mình ấn tượng nhất là error handling. Try/catch blocks giờ hoạt động bình thường với async code. Không còn .catch() chains phức tạp nữa.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync function layDuLieu() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    console.log('Dữ liệu đây:', data);\n    return data;\n  } catch (error) {\n    console.error('Lỗi rồi bạn ơi:', error);\n    throw error;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMình đã dành 2 tuần để chuyển đổi toàn bộ codebase. Ban đầu confusing lắm, nhưng giờ nhìn lại, code clean hẳn ra!\u003c/p\u003e\n\u003ch3\u003eXử lý nhiều requests - Bài toán khó nhất của mình\u003c/h3\u003e\n\u003cp\u003eLúc đầu, mình nghĩ fetch một API là đủ rồi. Nhưng khi làm project thực tế, mình cần fetch nhiều APIs cùng lúc. Đó là lúc mình học được Promise.all.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePromise.all - Chờ tất cả hoàn thành\u003c/strong\u003e\nMình có app cần load 5 users cùng lúc. Thay vì fetch tuần tự (chậm), mình dùng Promise.all để fetch song song. Performance tăng vọt!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync function layNhieuUsers(userIds) {\n  try {\n    const promises = userIds.map(id =\u003e\n      fetch(`https://api.example.com/users/${id}`)\n        .then(res =\u003e res.json())\n    );\n\n    const users = await Promise.all(promises);\n    console.log('Tất cả users:', users);\n    return users;\n  } catch (error) {\n    console.error('Có lỗi xảy ra:', error);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePromise.race - Timeout cho requests\u003c/strong\u003e\nNetwork không đáng tin cậy. Mình đã từng có request treo cả phút. Promise.race cứu cánh đấy!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync function fetchVoiTimeout(url, timeout = 5000) {\n  const fetchPromise = fetch(url);\n  const timeoutPromise = new Promise((_, reject) =\u003e\n    setTimeout(() =\u003e reject(new Error('Timeout!')), timeout)\n  );\n\n  try {\n    const response = await Promise.race([fetchPromise, timeoutPromise]);\n    return await response.json();\n  } catch (error) {\n    console.log('Request timeout hoặc lỗi:', error.message);\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMình đã áp dụng timeout cho tất cả API calls sau bài học đắt giá đó.\u003c/p\u003e\n\u003ch3\u003eRetry logic - Khi network \"làm biếng\"\u003c/h3\u003e\n\u003cp\u003eNetwork programming dạy mình rằng: thất bại là bình thường. Server có thể down, connection có thể đứt. Mình đã có project fail vì không handle retry properly.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBài học từ kinh nghiệm:\u003c/strong\u003e\nMình đã implement retry với exponential backoff. Lần đầu fail, thử lại sau 1s. Lần thứ 2 fail, thử lại sau 2s. Lần thứ 3 fail, thử lại sau 4s. Thông minh đúng không?\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync function fetchVoiRetry(url, maxRetries = 3) {\n  let delay = 1000;\n\n  for (let lanThu = 0; lanThu \u0026#x3C; maxRetries; lanThu++) {\n    try {\n      const response = await fetch(url);\n      if (response.ok) {\n        return await response.json();\n      }\n      throw new Error(`HTTP ${response.status}`);\n    } catch (error) {\n      if (lanThu === maxRetries - 1) {\n        throw error; // Đã thử hết rồi\n      }\n      console.log(`Lần ${lanThu + 1} fail, thử lại sau ${delay}ms...`);\n      await new Promise(resolve =\u003e setTimeout(resolve, delay));\n      delay *= 2; // Tăng delay\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSequential vs Parallel - Performance matters\u003c/h3\u003e\n\u003cp\u003eLúc đầu, mình viết code tuần tự (sequential) vì dễ hiểu. Nhưng khi có 10 requests, mất 10 giây thay vì 1 giây. Đó là lúc mình học parallel processing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSequential (chậm):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync function layTuTu(userIds) {\n  const users = [];\n  for (const id of userIds) {\n    const response = await fetch(`https://api.example.com/users/${id}`);\n    const user = await response.json();\n    users.push(user);\n  }\n  return users;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eParallel (nhanh):\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003easync function laySongSong(userIds) {\n  const promises = userIds.map(id =\u003e\n    fetch(`https://api.example.com/users/${id}`)\n      .then(res =\u003e res.json())\n  );\n  return await Promise.all(promises);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMình đã tối ưu performance project của mình từ 8 giây xuống 2 giây chỉ bằng cách này!\u003c/p\u003e\n\u003ch3\u003eError handling - Bài học đắt giá\u003c/h3\u003e\n\u003cp\u003eLúc đầu, mình nghĩ error handling là optional. \"Code chạy được là được rồi!\" Nhưng production dạy mình bài học đắt giá.\u003c/p\u003e\n\u003cp\u003eMình đã có lần app crash vì không handle network errors properly. Users thấy white screen, support tickets đổ về như mưa. Từ đó, mình implement comprehensive error handling.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGlobal error handler:\u003c/strong\u003e\nMình tạo một wrapper cho tất cả fetch calls. Log error, show user-friendly message, và report to monitoring service.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCancellation - Khi user không chờ nữa:\u003c/strong\u003e\nTrong app chat của mình, khi user chuyển trang, mình cần cancel pending requests. AbortController cứu cánh đấy!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eclass FetchCoTheHuy {\n  constructor(url) {\n    this.controller = new AbortController();\n    this.signal = this.controller.signal;\n    this.promise = fetch(url, { signal: this.signal });\n  }\n\n  cancel() {\n    this.controller.abort();\n  }\n\n  async get() {\n    try {\n      const response = await this.promise;\n      return await response.json();\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        console.log('User đã cancel request');\n        return null;\n      }\n      throw error;\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMình đã prevent nhiều memory leaks nhờ cancellation pattern này.\u003c/p\u003e\n\u003ch2\u003eNhững gì mình học được sau nhiều tháng vật lộn với async\u003c/h2\u003e\n\u003cp\u003eSau khi hoàn thành môn JavaScript nâng cao, mình có thể tự tin nói: async programming đã thay đổi cách mình code forever.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThứ nhất: Từ confuse đến master\u003c/strong\u003e\nLúc đầu, Promise, async/await làm mình đau đầu. Nhưng khi hiểu được, mọi thứ trở nên logical. Mình có thể handle complex async flows dễ dàng.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThứ hai: Performance optimization thực tế\u003c/strong\u003e\nMình đã tối ưu project từ 8 giây load time xuống 2 giây chỉ bằng Promise.all. Đó là khoảnh khắc \"wow\" khi thấy code thực sự matters.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThứ ba: Error handling is everything\u003c/strong\u003e\nNetwork unreliable lắm. Retry logic, timeout, cancellation - những concepts này giờ thành reflex của mình.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThứ tư: Code quality improvement\u003c/strong\u003e\nAsync/await làm code readable hơn hẳn. Teammates có thể hiểu và maintain dễ dàng. Testing cũng đơn giản hơn nhiều.\u003c/p\u003e\n\u003ch2\u003eKết luận: Async programming - Journey của một sinh viên\u003c/h2\u003e\n\u003cp\u003eAsync/await không chỉ là syntax - mà là mindset shift. Từ việc sợ asynchronous code, giờ mình có thể build scalable network applications.\u003c/p\u003e\n\u003cp\u003eNếu bạn đang học JavaScript và thấy async confusing, đừng nản nhé! Mình cũng từng như bạn. Hãy bắt đầu với simple Promise, rồi dần dần lên async/await. Practice nhiều, debug nhiều, và bạn sẽ conquer được.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLời khuyên cho sinh viên:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBắt đầu với Promise chains trước khi nhảy vào async/await\u003c/li\u003e\n\u003cli\u003ePractice với nhiều network requests để hiểu performance\u003c/li\u003e\n\u003cli\u003eImplement error handling từ early stage\u003c/li\u003e\n\u003cli\u003eĐừng ngại refactor - từ callbacks sang async/await đáng effort lắm\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNếu bài này giúp ích được gì, hãy share cho bạn bè cùng lớp nhé! Async programming khó nhưng khi conquer được, bạn sẽ thấy nó amazing lắm.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eP.S: Đây là kinh nghiệm học tập của mình. Nếu bạn thấy bài viết hữu ích, hãy share cho bạn bè cùng học nhé!\u003c/em\u003e\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"div\",null,{\"className\":\"pt-16 min-h-screen bg-[#f0f2f5]\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12\",\"children\":[[\"$\",\"$L10\",null,{\"href\":\"/blog\",\"className\":\"inline-flex items-center gap-2 text-[#b16cea] hover:text-[#ff5e69] mb-8 transition-colors font-medium\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left w-5 h-5\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],[\"$\",\"span\",null,{\"children\":\"Quay lại Blog\"}]]}],[\"$\",\"div\",null,{\"className\":\"bg-white rounded-xl shadow-sm border border-gray-200 p-8 md:p-12 mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl md:text-5xl font-bold text-[#161513] mb-4 leading-tight\",\"children\":\"JavaScript Async Network Operations\"}],[\"$\",\"p\",null,{\"className\":\"text-lg text-gray-600 leading-relaxed mb-6\",\"children\":\"Tìm hiểu về xử lý bất đồng bộ trong network programming với async/await, Promises, và các kỹ thuật xử lý nhiều network operations đồng thời.\"}],[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between flex-wrap gap-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2\",\"children\":[[\"$\",\"span\",\"JavaScript\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"JavaScript\"}],[\"$\",\"span\",\"Async\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Async\"}],[\"$\",\"span\",\"Await\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Await\"}],[\"$\",\"span\",\"Promises\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Promises\"}],[\"$\",\"span\",\"Network Programming\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Network Programming\"}]]}],[\"$\",\"span\",null,{\"className\":\"text-sm text-gray-500 whitespace-nowrap\",\"style\":{\"fontFamily\":\"var(--font-inter)\"},\"children\":\"2024-04-20\"}]]}]]}],[\"$\",\"article\",null,{\"className\":\"mb-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"prose prose-lg max-w-none prose-headings:text-[#161513] prose-p:text-[#374151] prose-p:leading-relaxed prose-a:text-[#b16cea] prose-a:no-underline hover:prose-a:underline prose-strong:text-[#161513] prose-code:text-[#b16cea] prose-code:bg-gray-100 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-pre:bg-[#1f2937] prose-pre:rounded-lg prose-h2:text-2xl prose-h2:font-bold prose-h2:mt-12 prose-h2:mb-6 prose-h3:text-xl prose-h3:font-semibold prose-h3:mt-8 prose-h3:mb-4\",\"dangerouslySetInnerHTML\":{\"__html\":\"$11\"}}]}],\"$L12\",\"$L13\"]}]}]\n"])</script><script>self.__next_f.push([1,"14:I[8437,[\"437\",\"static/chunks/437-662f772b2654fde0.js\",\"500\",\"static/chunks/500-3ff701859ea2af56.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js\"],\"Image\"]\n15:I[8846,[\"437\",\"static/chunks/437-662f772b2654fde0.js\",\"500\",\"static/chunks/500-3ff701859ea2af56.js\",\"953\",\"static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"12:[\"$\",\"div\",null,{\"className\":\"bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between flex-wrap gap-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"relative w-16 h-16 rounded-full overflow-hidden bg-gradient-to-br from-indigo-400 to-purple-500 flex-shrink-0\",\"children\":[\"$\",\"$L14\",null,{\"src\":\"/images/avatar/avatar.png\",\"alt\":\"Truong Yen Phuong\",\"fill\":true,\"className\":\"object-cover\"}]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"font-semibold text-[#161513] text-lg mb-1\",\"children\":\"Truong Yen Phuong\"}],[\"$\",\"p\",null,{\"className\":\"text-sm text-gray-600\",\"children\":\"Tổng hợp kinh nghiệm\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4 flex-wrap\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-2\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-share2 lucide-share-2 w-5 h-5 text-[#b16cea]\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"circle\",\"gq8acd\",{\"cx\":\"18\",\"cy\":\"5\",\"r\":\"3\"}],[\"$\",\"circle\",\"w7nqdw\",{\"cx\":\"6\",\"cy\":\"12\",\"r\":\"3\"}],[\"$\",\"circle\",\"1xt0gg\",{\"cx\":\"18\",\"cy\":\"19\",\"r\":\"3\"}],[\"$\",\"line\",\"47mynk\",{\"x1\":\"8.59\",\"x2\":\"15.42\",\"y1\":\"13.51\",\"y2\":\"17.49\"}],[\"$\",\"line\",\"1n3mei\",{\"x1\":\"15.41\",\"x2\":\"8.59\",\"y1\":\"6.51\",\"y2\":\"10.49\"}],\"$undefined\"]}],[\"$\",\"span\",null,{\"className\":\"font-semibold text-[#161513]\",\"children\":\"Chia sẻ bài viết:\"}]]}],[\"$\",\"$L15\",null,{\"title\":\"JavaScript Async Network Operations\",\"slug\":\"javascript-async\"}]]}]]}]}]\n"])</script><script>self.__next_f.push([1,"13:[\"$\",\"div\",null,{\"className\":\"text-center\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"/blog\",\"className\":\"inline-flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-[#b16cea] to-[#ff5e69] text-white rounded-lg font-semibold hover:opacity-90 transition-opacity\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left w-5 h-5\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],\"Xem tất cả bài viết\"]}]}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"16:I[6869,[],\"IconMark\"]\na:null\ne:[[\"$\",\"title\",\"0\",{\"children\":\"JavaScript Async Network Operations - Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Tìm hiểu về xử lý bất đồng bộ trong network programming với async/await, Promises, và các kỹ thuật xử lý nhiều network operations đồng thời.\"}],[\"$\",\"meta\",\"2\",{\"name\":\"author\",\"content\":\"Fang\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"Frontend Developer,UI/UX Designer,React,Next.js,JavaScript,Java,Portfolio\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Truong Yen Phuong | Portfolio\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"Portfolio và Blog cá nhân về Frontend Development và UI/UX Design\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Truong Yen Phuong | Portfolio\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"Portfolio và Blog cá nhân về Frontend Development và UI/UX Design\"}],[\"$\",\"link\",\"10\",{\"rel\":\"icon\",\"href\":\"/portfolio-blog/favicon.ico?9e65197c8e8dbd7e\",\"type\":\"image/x-icon\",\"sizes\":\"454x454\"}],[\"$\",\"$L16\",\"11\",{}]]\n"])</script></body></html>