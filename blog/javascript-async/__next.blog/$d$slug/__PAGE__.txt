1:"$Sreact.fragment"
2:I[8500,["437","static/chunks/437-662f772b2654fde0.js","500","static/chunks/500-3ff701859ea2af56.js","953","static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js"],""]
7:I[8437,["437","static/chunks/437-662f772b2654fde0.js","500","static/chunks/500-3ff701859ea2af56.js","953","static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js"],"Image"]
8:I[8846,["437","static/chunks/437-662f772b2654fde0.js","500","static/chunks/500-3ff701859ea2af56.js","953","static/chunks/app/blog/%5Bslug%5D/page-c28593380643696f.js"],"default"]
9:I[484,[],"OutletBoundary"]
a:"$Sreact.suspense"
3:T284c,<h2>Vấn đề callback hell trong network programming</h2>
<p>Bạn đã bao giờ thấy code JavaScript với vô số nested callbacks? Đó là callback hell - khi network operations tạo thành một kim tự tháp khó maintain.</p>
<pre><code class="language-javascript">// Callback hell - khó đọc, khó debug
fetch('/api/user', (user) => {
  fetch(`/api/posts/${user.id}`, (posts) => {
    fetch(`/api/comments/${posts[0].id}`, (comments) => {
      // Còn nữa...
    });
  });
});
</code></pre>
<p>JavaScript evolution từ callbacks → Promises → async/await để giải quyết vấn đề này. Async programming giờ trở nên tự nhiên và dễ hiểu.</p>
<h2>Promises - Khi mình bắt đầu học async</h2>
<p>Lúc đầu học JavaScript, mình nghe khái niệm Promise mà confuse lắm. "Promise là cái gì? Tại sao lại có pending, fulfilled, rejected?" Mình đã dành cả buổi tối để đọc docs về Promise, nhưng vẫn mò mẫm.</p>
<p>Rồi mình hiểu ra: Promise là một "lời hứa" - bạn request cái gì đó, và Promise hứa sẽ trả về kết quả trong tương lai. Với network requests, fetch() trả về Promise ngay lập tức, nhưng data thì chưa có.</p>
<p>Mình nhớ lần đầu tiên dùng Promise thành công. Thay vì callback hell, mình có thể chain các .then() lại với nhau. Đơn giản hơn nhiều!</p>
<pre><code class="language-javascript">// Promise đầu tiên của mình
fetch('/api/user')
  .then(response => response.json())
  .then(user => {
    console.log('Được rồi! User:', user);
    return fetch(`/api/posts/${user.id}`);
  })
  .then(response => response.json())
  .then(posts => {
    console.log('Posts cũng có rồi:', posts);
  })
  .catch(error => {
    console.error('Ối, lỗi rồi:', error);
  });
</code></pre>
<h3>Async/Await - "Aha moment" của mình</h3>
<p>Rồi một ngày, mình học được async/await. Wow! Code bất đồng bộ giờ trông giống synchronous code hẳn. Mình đã refactor toàn bộ project cá nhân từ Promise chains sang async/await.</p>
<p>Điều làm mình ấn tượng nhất là error handling. Try/catch blocks giờ hoạt động bình thường với async code. Không còn .catch() chains phức tạp nữa.</p>
<pre><code class="language-javascript">async function layDuLieu() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log('Dữ liệu đây:', data);
    return data;
  } catch (error) {
    console.error('Lỗi rồi bạn ơi:', error);
    throw error;
  }
}
</code></pre>
<p>Mình đã dành 2 tuần để chuyển đổi toàn bộ codebase. Ban đầu confusing lắm, nhưng giờ nhìn lại, code clean hẳn ra!</p>
<h3>Xử lý nhiều requests - Bài toán khó nhất của mình</h3>
<p>Lúc đầu, mình nghĩ fetch một API là đủ rồi. Nhưng khi làm project thực tế, mình cần fetch nhiều APIs cùng lúc. Đó là lúc mình học được Promise.all.</p>
<p><strong>Promise.all - Chờ tất cả hoàn thành</strong>
Mình có app cần load 5 users cùng lúc. Thay vì fetch tuần tự (chậm), mình dùng Promise.all để fetch song song. Performance tăng vọt!</p>
<pre><code class="language-javascript">async function layNhieuUsers(userIds) {
  try {
    const promises = userIds.map(id =>
      fetch(`https://api.example.com/users/${id}`)
        .then(res => res.json())
    );

    const users = await Promise.all(promises);
    console.log('Tất cả users:', users);
    return users;
  } catch (error) {
    console.error('Có lỗi xảy ra:', error);
  }
}
</code></pre>
<p><strong>Promise.race - Timeout cho requests</strong>
Network không đáng tin cậy. Mình đã từng có request treo cả phút. Promise.race cứu cánh đấy!</p>
<pre><code class="language-javascript">async function fetchVoiTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) =>
    setTimeout(() => reject(new Error('Timeout!')), timeout)
  );

  try {
    const response = await Promise.race([fetchPromise, timeoutPromise]);
    return await response.json();
  } catch (error) {
    console.log('Request timeout hoặc lỗi:', error.message);
  }
}
</code></pre>
<p>Mình đã áp dụng timeout cho tất cả API calls sau bài học đắt giá đó.</p>
<h3>Retry logic - Khi network "làm biếng"</h3>
<p>Network programming dạy mình rằng: thất bại là bình thường. Server có thể down, connection có thể đứt. Mình đã có project fail vì không handle retry properly.</p>
<p><strong>Bài học từ kinh nghiệm:</strong>
Mình đã implement retry với exponential backoff. Lần đầu fail, thử lại sau 1s. Lần thứ 2 fail, thử lại sau 2s. Lần thứ 3 fail, thử lại sau 4s. Thông minh đúng không?</p>
<pre><code class="language-javascript">async function fetchVoiRetry(url, maxRetries = 3) {
  let delay = 1000;

  for (let lanThu = 0; lanThu &#x3C; maxRetries; lanThu++) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        return await response.json();
      }
      throw new Error(`HTTP ${response.status}`);
    } catch (error) {
      if (lanThu === maxRetries - 1) {
        throw error; // Đã thử hết rồi
      }
      console.log(`Lần ${lanThu + 1} fail, thử lại sau ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
      delay *= 2; // Tăng delay
    }
  }
}
</code></pre>
<h3>Sequential vs Parallel - Performance matters</h3>
<p>Lúc đầu, mình viết code tuần tự (sequential) vì dễ hiểu. Nhưng khi có 10 requests, mất 10 giây thay vì 1 giây. Đó là lúc mình học parallel processing.</p>
<p><strong>Sequential (chậm):</strong></p>
<pre><code class="language-javascript">async function layTuTu(userIds) {
  const users = [];
  for (const id of userIds) {
    const response = await fetch(`https://api.example.com/users/${id}`);
    const user = await response.json();
    users.push(user);
  }
  return users;
}
</code></pre>
<p><strong>Parallel (nhanh):</strong></p>
<pre><code class="language-javascript">async function laySongSong(userIds) {
  const promises = userIds.map(id =>
    fetch(`https://api.example.com/users/${id}`)
      .then(res => res.json())
  );
  return await Promise.all(promises);
}
</code></pre>
<p>Mình đã tối ưu performance project của mình từ 8 giây xuống 2 giây chỉ bằng cách này!</p>
<h3>Error handling - Bài học đắt giá</h3>
<p>Lúc đầu, mình nghĩ error handling là optional. "Code chạy được là được rồi!" Nhưng production dạy mình bài học đắt giá.</p>
<p>Mình đã có lần app crash vì không handle network errors properly. Users thấy white screen, support tickets đổ về như mưa. Từ đó, mình implement comprehensive error handling.</p>
<p><strong>Global error handler:</strong>
Mình tạo một wrapper cho tất cả fetch calls. Log error, show user-friendly message, và report to monitoring service.</p>
<p><strong>Cancellation - Khi user không chờ nữa:</strong>
Trong app chat của mình, khi user chuyển trang, mình cần cancel pending requests. AbortController cứu cánh đấy!</p>
<pre><code class="language-javascript">class FetchCoTheHuy {
  constructor(url) {
    this.controller = new AbortController();
    this.signal = this.controller.signal;
    this.promise = fetch(url, { signal: this.signal });
  }

  cancel() {
    this.controller.abort();
  }

  async get() {
    try {
      const response = await this.promise;
      return await response.json();
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('User đã cancel request');
        return null;
      }
      throw error;
    }
  }
}
</code></pre>
<p>Mình đã prevent nhiều memory leaks nhờ cancellation pattern này.</p>
<h2>Những gì mình học được sau nhiều tháng vật lộn với async</h2>
<p>Sau khi hoàn thành môn JavaScript nâng cao, mình có thể tự tin nói: async programming đã thay đổi cách mình code forever.</p>
<p><strong>Thứ nhất: Từ confuse đến master</strong>
Lúc đầu, Promise, async/await làm mình đau đầu. Nhưng khi hiểu được, mọi thứ trở nên logical. Mình có thể handle complex async flows dễ dàng.</p>
<p><strong>Thứ hai: Performance optimization thực tế</strong>
Mình đã tối ưu project từ 8 giây load time xuống 2 giây chỉ bằng Promise.all. Đó là khoảnh khắc "wow" khi thấy code thực sự matters.</p>
<p><strong>Thứ ba: Error handling is everything</strong>
Network unreliable lắm. Retry logic, timeout, cancellation - những concepts này giờ thành reflex của mình.</p>
<p><strong>Thứ tư: Code quality improvement</strong>
Async/await làm code readable hơn hẳn. Teammates có thể hiểu và maintain dễ dàng. Testing cũng đơn giản hơn nhiều.</p>
<h2>Kết luận: Async programming - Journey của một sinh viên</h2>
<p>Async/await không chỉ là syntax - mà là mindset shift. Từ việc sợ asynchronous code, giờ mình có thể build scalable network applications.</p>
<p>Nếu bạn đang học JavaScript và thấy async confusing, đừng nản nhé! Mình cũng từng như bạn. Hãy bắt đầu với simple Promise, rồi dần dần lên async/await. Practice nhiều, debug nhiều, và bạn sẽ conquer được.</p>
<p><strong>Lời khuyên cho sinh viên:</strong></p>
<ul>
<li>Bắt đầu với Promise chains trước khi nhảy vào async/await</li>
<li>Practice với nhiều network requests để hiểu performance</li>
<li>Implement error handling từ early stage</li>
<li>Đừng ngại refactor - từ callbacks sang async/await đáng effort lắm</li>
</ul>
<p>Nếu bài này giúp ích được gì, hãy share cho bạn bè cùng lớp nhé! Async programming khó nhưng khi conquer được, bạn sẽ thấy nó amazing lắm.</p>
<p><em>P.S: Đây là kinh nghiệm học tập của mình. Nếu bạn thấy bài viết hữu ích, hãy share cho bạn bè cùng học nhé!</em></p>
0:{"buildId":"ciNN1PgoOFpih67RIzoK1","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"pt-16 min-h-screen bg-[#f0f2f5]","children":["$","div",null,{"className":"max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12","children":[["$","$L2",null,{"href":"/blog","className":"inline-flex items-center gap-2 text-[#b16cea] hover:text-[#ff5e69] mb-8 transition-colors font-medium","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left w-5 h-5","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],["$","span",null,{"children":"Quay lại Blog"}]]}],["$","div",null,{"className":"bg-white rounded-xl shadow-sm border border-gray-200 p-8 md:p-12 mb-8","children":[["$","h1",null,{"className":"text-3xl md:text-5xl font-bold text-[#161513] mb-4 leading-tight","children":"JavaScript Async Network Operations"}],["$","p",null,{"className":"text-lg text-gray-600 leading-relaxed mb-6","children":"Tìm hiểu về xử lý bất đồng bộ trong network programming với async/await, Promises, và các kỹ thuật xử lý nhiều network operations đồng thời."}],["$","div",null,{"className":"flex items-center justify-between flex-wrap gap-4","children":[["$","div",null,{"className":"flex flex-wrap gap-2","children":[["$","span","JavaScript",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"JavaScript"}],["$","span","Async",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"Async"}],["$","span","Await",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"Await"}],["$","span","Promises",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"Promises"}],["$","span","Network Programming",{"className":"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium","children":"Network Programming"}]]}],["$","span",null,{"className":"text-sm text-gray-500 whitespace-nowrap","style":{"fontFamily":"var(--font-inter)"},"children":"2024-04-20"}]]}]]}],["$","article",null,{"className":"mb-12","children":["$","div",null,{"className":"prose prose-lg max-w-none prose-headings:text-[#161513] prose-p:text-[#374151] prose-p:leading-relaxed prose-a:text-[#b16cea] prose-a:no-underline hover:prose-a:underline prose-strong:text-[#161513] prose-code:text-[#b16cea] prose-code:bg-gray-100 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-pre:bg-[#1f2937] prose-pre:rounded-lg prose-h2:text-2xl prose-h2:font-bold prose-h2:mt-12 prose-h2:mb-6 prose-h3:text-xl prose-h3:font-semibold prose-h3:mt-8 prose-h3:mb-4","dangerouslySetInnerHTML":{"__html":"$3"}}]}],"$L4","$L5"]}]}],null,"$L6"]}],"loading":null,"isPartial":false}
4:["$","div",null,{"className":"bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8","children":["$","div",null,{"className":"flex items-center justify-between flex-wrap gap-6","children":[["$","div",null,{"className":"flex items-center gap-4","children":[["$","div",null,{"className":"relative w-16 h-16 rounded-full overflow-hidden bg-gradient-to-br from-indigo-400 to-purple-500 flex-shrink-0","children":["$","$L7",null,{"src":"/images/avatar/avatar.png","alt":"Truong Yen Phuong","fill":true,"className":"object-cover"}]}],["$","div",null,{"children":[["$","h3",null,{"className":"font-semibold text-[#161513] text-lg mb-1","children":"Truong Yen Phuong"}],["$","p",null,{"className":"text-sm text-gray-600","children":"Tổng hợp kinh nghiệm"}]]}]]}],["$","div",null,{"className":"flex items-center gap-4 flex-wrap","children":[["$","div",null,{"className":"flex items-center gap-2","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-share2 lucide-share-2 w-5 h-5 text-[#b16cea]","aria-hidden":"true","children":[["$","circle","gq8acd",{"cx":"18","cy":"5","r":"3"}],["$","circle","w7nqdw",{"cx":"6","cy":"12","r":"3"}],["$","circle","1xt0gg",{"cx":"18","cy":"19","r":"3"}],["$","line","47mynk",{"x1":"8.59","x2":"15.42","y1":"13.51","y2":"17.49"}],["$","line","1n3mei",{"x1":"15.41","x2":"8.59","y1":"6.51","y2":"10.49"}],"$undefined"]}],["$","span",null,{"className":"font-semibold text-[#161513]","children":"Chia sẻ bài viết:"}]]}],["$","$L8",null,{"title":"JavaScript Async Network Operations","slug":"javascript-async"}]]}]]}]}]
5:["$","div",null,{"className":"text-center","children":["$","$L2",null,{"href":"/blog","className":"inline-flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-[#b16cea] to-[#ff5e69] text-white rounded-lg font-semibold hover:opacity-90 transition-opacity","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left w-5 h-5","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"Xem tất cả bài viết"]}]}]
6:["$","$L9",null,{"children":["$","$a",null,{"name":"Next.MetadataOutlet","children":"$@b"}]}]
b:null
