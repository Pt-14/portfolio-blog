<!DOCTYPE html><!--FFLv47kkbcVThbBtn6b5h--><html lang="vi" class="scroll-smooth"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/portfolio-blog/_next/static/media/137e738a3044ae84-s.p.238dcd1b.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/portfolio-blog/_next/static/media/186c8edb2e53be7f-s.p.c99fd3fd.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/portfolio-blog/_next/static/media/83afe278b6a6bb3c-s.p.3a6ba036.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/portfolio-blog/_next/static/media/a3c73b24938559c3-s.p.bab49f4c.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/portfolio-blog/_next/static/media/fb30396e64817371-s.p.f046f548.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/portfolio-blog/_next/static/chunks/14299e94805ff3d3.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/portfolio-blog/_next/static/chunks/4598cc32edf4e870.js"/><script src="/portfolio-blog/_next/static/chunks/f902e0ff89a974d7.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/11b03c15c8b0d496.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/4ce230393c67cd83.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/turbopack-35c0ac2871311419.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/2ea5f535648d11e4.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/9c7410708860575f.js" async=""></script><script src="/portfolio-blog/_next/static/chunks/88ef56c00aa0fcf7.js" async=""></script><meta name="next-size-adjust" content=""/><title>Đa tuyến và Xử lý đồng thời trong Java - Blog</title><meta name="description" content="Tìm hiểu về Multithreading và Concurrency trong Java - cách tạo và quản lý threads, xử lý nhiều client đồng thời trong lập trình mạng."/><meta name="author" content="Fang"/><meta name="keywords" content="Frontend Developer,UI/UX Designer,React,Next.js,JavaScript,Java,Portfolio"/><meta property="og:title" content="Truong Yen Phuong | Portfolio"/><meta property="og:description" content="Portfolio và Blog cá nhân về Frontend Development và UI/UX Design"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Truong Yen Phuong | Portfolio"/><meta name="twitter:description" content="Portfolio và Blog cá nhân về Frontend Development và UI/UX Design"/><link rel="icon" href="/portfolio-blog/favicon.ico?favicon.3546e4df.ico" sizes="454x454" type="image/x-icon"/><script src="/portfolio-blog/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="bai_jamjuree_2f3e59e-module__uL3GvG__variable inter_5901b7c6-module__ec5Qua__variable font-sans antialiased bg-[#f0f2f5]"><div hidden=""><!--$--><!--/$--></div><nav class="fixed z-50 transition-all duration-700 ease-out top-0 left-0 right-0 rounded-none bg-[#f0f2f5]/95 backdrop-blur-xl border-b" style="border-color:var(--color--transparent)"><div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8"><div class="relative flex justify-between items-center h-16 transition-all duration-700"><div class="flex items-center"><a class="hover:opacity-80 transition-opacity duration-300" href="/portfolio-blog/"><span class="text-[28px] font-bold text-[#161513]">Fang.</span></a></div><div class="hidden md:flex items-center space-x-6 absolute left-1/2 transform -translate-x-1/2"><a class="px-3 py-2 text-base font-medium transition-all duration-300 text-[#161513] hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent" href="/portfolio-blog/">Trang chủ</a><a class="px-3 py-2 text-base font-medium transition-all duration-300 text-[#161513] hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent" href="/portfolio-blog/certificates/">Chứng chỉ</a><a class="px-3 py-2 text-base font-medium transition-all duration-300 bg-gradient-to-r from-[#b16cea] via-[#ff5e69] via-[#ff8a56] to-[#ffa84b] bg-clip-text text-transparent" href="/portfolio-blog/blog/">Bài viết</a><a class="px-3 py-2 text-base font-medium transition-all duration-300 text-[#161513] hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent" href="/portfolio-blog/about/">Giới thiệu</a></div><div class="flex items-center space-x-4"><div class="hidden md:block"><div class="relative overflow-hidden bg-[#161513] rounded-full group"><a class="relative block text-[#f0f2f5] px-5 py-2.5 text-sm font-medium transition-colors duration-300 group-hover:text-white z-10" href="/portfolio-blog/contact/">Liên hệ</a><div class="absolute inset-0 bg-gradient-to-r from-[#b16cea] via-[#ff5e69] via-[#ff8a56] to-[#ffa84b] transform -translate-x-full group-hover:translate-x-0 transition-transform duration-500 ease-out pointer-events-none"></div></div></div><div class="hidden md:block ml-2"><div class="flex items-center gap-2 text-sm font-medium"><button class="transition-all duration-300 text-[#161513]">VI</button><div class="w-px h-4 bg-gray-300"></div><button class="transition-all duration-300 text-gray-400 hover:bg-gradient-to-r hover:from-[#b16cea] hover:via-[#ff5e69] hover:via-[#ff8a56] hover:to-[#ffa84b] hover:bg-clip-text hover:text-transparent">EN</button></div></div><button class="md:hidden p-2 rounded-md text-gray-700 hover:bg-gray-100 transition-colors duration-300" aria-label="Toggle menu"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg></button></div></div></div></nav><main class="min-h-screen"><div class="pt-16 min-h-screen bg-[#f0f2f5]"><div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12"><a class="inline-flex items-center gap-2 text-[#b16cea] hover:text-[#ff5e69] mb-8 transition-colors font-medium" href="/portfolio-blog/blog/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left w-5 h-5" aria-hidden="true"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg><span>Quay lại Blog</span></a><div class="bg-white rounded-xl shadow-sm border border-gray-200 p-8 md:p-12 mb-8"><h1 class="text-3xl md:text-5xl font-bold text-[#161513] mb-4 leading-tight">Đa tuyến và Xử lý đồng thời trong Java</h1><p class="text-lg text-gray-600 leading-relaxed mb-6">Tìm hiểu về Multithreading và Concurrency trong Java - cách tạo và quản lý threads, xử lý nhiều client đồng thời trong lập trình mạng.</p><div class="flex items-center justify-between flex-wrap gap-4"><div class="flex flex-wrap gap-2"><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Java</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Multithreading</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Concurrency</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">Threads</span><span class="px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium">ExecutorService</span></div><span class="text-sm text-gray-500 whitespace-nowrap" style="font-family:var(--font-inter)">2024-04-05</span></div></div><article class="mb-12"><div class="prose prose-lg max-w-none prose-headings:text-[#161513] prose-p:text-[#374151] prose-p:leading-relaxed prose-a:text-[#b16cea] prose-a:no-underline hover:prose-a:underline prose-strong:text-[#161513] prose-code:text-[#b16cea] prose-code:bg-gray-100 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-pre:bg-[#1f2937] prose-pre:rounded-lg prose-h2:text-2xl prose-h2:font-bold prose-h2:mt-12 prose-h2:mb-6 prose-h3:text-xl prose-h3:font-semibold prose-h3:mt-8 prose-h3:mb-4"><h2>Khi server của mình bị "đơ" vì quá tải</h2>
<p>Xin chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học Multithreading trong Java. Đây là chủ đề mà lúc đầu mình thấy siêu khó hiểu, concurrency concepts phức tạp, race conditions, deadlocks - nghe đã muốn bỏ cuộc.</p>
<p>Mình còn nhớ project đầu tiên: làm một simple chat server. Ban đầu dùng single thread, code đơn giản:</p>
<pre><code class="language-java">while (true) {
    Socket client = serverSocket.accept();
    handleClient(client); // Xử lý từng client một
}
</code></pre>
<p>Nhưng khi test với 2-3 clients cùng lúc, ôi trời ơi! Server bị "đơ" cứng. Client thứ 2 phải chờ client thứ 1 gõ xong, send xong mới được phục vụ. Với 10 clients? Server lag muốn chết.</p>
<p>Mình ngồi debug cả đêm, rồi học được multithreading. Wow! Từ single thread handle 1 client, giờ server có thể xử lý 1000+ clients đồng thời. Sự khác biệt như từ xe đạp lên ô tô vậy.</p>
<p><strong>Tại sao multithreading quan trọng trong network programming?</strong></p>
<ul>
<li>Mỗi client cần thread riêng (network I/O thường block)</li>
<li>Server phải responsive, không được "đơ" vì 1 client chậm</li>
<li>Tận dụng multi-core CPU hiệu quả hơn</li>
</ul>
<p>Đó là lúc mình hiểu: multithreading không chỉ là "best practice" - mà là bắt buộc cho server applications.</p>
<h2>Học cách tạo thread - Từ confuse đến "aha!"</h2>
<p>Lúc đầu học multithreading, mình confuse với Thread class và Runnable interface. "Tại sao có 2 cách? Cách nào tốt hơn?"</p>
<p><strong>Cách 1: Extend Thread class</strong>
Mình thử implement đầu tiên bằng cách extend Thread:</p>
<pre><code class="language-java">public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Hello from thread: " + getName());
        // Xử lý logic ở đây
    }
}

// Sử dụng
MyThread thread = new MyThread();
thread.start();
</code></pre>
<p>Nhưng rồi mình học được: Java không support multiple inheritance. Nếu class đã extend class khác thì sao? Đó là lúc mình biết đến Runnable.</p>
<p><strong>Cách 2: Implement Runnable (mình dùng cách này)</strong></p>
<pre><code class="language-java">public class ClientHandler implements Runnable {
    @Override
    public void run() {
        System.out.println("Handling client in thread: " + Thread.currentThread().getName());
        // Xử lý client logic
    }
}

// Sử dụng
Thread thread = new Thread(new ClientHandler());
thread.start();
</code></pre>
<p>Runnable flexible hơn vì có thể implement multiple interfaces. Bây giờ mình luôn dùng Runnable cho client handlers.</p>
<p><strong>Lambda với Runnable (Java 8+)</strong>
Mình thích cách này nhất vì concise:</p>
<pre><code class="language-java">Thread thread = new Thread(() -> {
    System.out.println("Client handled by: " + Thread.currentThread().getName());
});
thread.start();
</code></pre>
<p>Từ khi học được Runnable, multithreading code của mình clean hẳn ra.</p>
<h3>Thread là gì?</h3>
<p>Thread (luồng) là đơn vị nhỏ nhất của việc thực thi trong một chương trình. Một chương trình Java có thể có nhiều threads chạy đồng thời, cho phép thực hiện nhiều tác vụ cùng lúc.</p>
<p><strong>Lợi ích của Multithreading:</strong></p>
<ul>
<li>Tận dụng tối đa CPU (đặc biệt với multi-core processors)</li>
<li>Cải thiện responsiveness của ứng dụng</li>
<li>Xử lý nhiều client đồng thời trong network programming</li>
</ul>
<h3>Tạo Thread - Các cách cơ bản</h3>
<h4>Cách 1: Extend Thread class</h4>
<pre><code class="language-java">public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread đang chạy: " + Thread.currentThread().getName());
        for (int i = 0; i &#x3C; 5; i++) {
            System.out.println("Count: " + i);
            try {
                Thread.sleep(1000); // Ngủ 1 giây
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        
        thread1.start(); // Bắt đầu thread
        thread2.start();
    }
}
</code></pre>
<h4>Cách 2: Implement Runnable interface (Khuyến nghị)</h4>
<pre><code class="language-java">public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread đang chạy: " + Thread.currentThread().getName());
    }
    
    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyRunnable());
        Thread thread2 = new Thread(new MyRunnable());
        
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<h4>Cách 3: Lambda Expression (Java 8+)</h4>
<pre><code class="language-java">public class LambdaThread {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            System.out.println("Thread chạy với lambda: " + 
                Thread.currentThread().getName());
        });
        thread.start();
    }
}
</code></pre>
<h3>Thread Pool - Bài học về resource management</h3>
<p>Lúc đầu, mình tạo thread mới cho mỗi client. Với 100 clients? 100 threads! Mình thấy memory usage tăng vọt, CPU spike, rồi OutOfMemoryError.</p>
<p><strong>Thread Pool - Lifesaver:</strong>
Mình học được ExecutorService - thread pool để tái sử dụng threads. Thay vì tạo/destroy threads liên tục, pool manage một số lượng threads cố định.</p>
<pre><code class="language-java">ExecutorService threadPool = Executors.newFixedThreadPool(10); // Max 10 threads

for (int i = 0; i &#x3C; 100; i++) {
    final int clientId = i;
    threadPool.submit(() -> {
        System.out.println("Handling client " + clientId + 
            " on " + Thread.currentThread().getName());
        // Process client
    });
}

threadPool.shutdown(); // Đóng pool khi xong
</code></pre>
<p><strong>Performance improvement:</strong></p>
<ul>
<li>Trước: 100 threads → memory issues</li>
<li>Sau: 10 threads tái sử dụng → stable, efficient</li>
</ul>
<p>Mình đã tối ưu server từ crash với 50 clients lên handle 1000+ clients smoothly.</p>
<p><strong>Network server với thread pool:</strong>
Trong server thực tế, mình dùng thread pool cho tất cả client connections. Mỗi client được xử lý trong thread riêng từ pool, server không bao giờ overload.</p>
<pre><code class="language-java">import java.net.ServerSocket;
import java.net.Socket;
import java.io.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThreadedServer {
    private static final int PORT = 8080;
    private static final int MAX_THREADS = 10;
    private static ExecutorService threadPool = 
        Executors.newFixedThreadPool(MAX_THREADS);
    
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("Server đang lắng nghe trên port " + PORT);
            
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("Client kết nối: " + 
                    clientSocket.getInetAddress());
                
                // Xử lý client trong thread pool
                threadPool.submit(new ClientHandler(clientSocket));
            }
        } catch (IOException e) {
            System.err.println("Lỗi server: " + e.getMessage());
        } finally {
            threadPool.shutdown();
        }
    }
    
    // Inner class để xử lý từng client
    static class ClientHandler implements Runnable {
        private Socket clientSocket;
        
        public ClientHandler(Socket socket) {
            this.clientSocket = socket;
        }
        
        @Override
        public void run() {
            try (BufferedReader in = new BufferedReader(
                    new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(
                    clientSocket.getOutputStream(), true)) {
                
                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    System.out.println("Thread " + Thread.currentThread().getName() + 
                        " nhận: " + inputLine);
                    
                    // Xử lý message
                    String response = "Echo: " + inputLine;
                    out.println(response);
                    
                    if ("quit".equalsIgnoreCase(inputLine)) {
                        break;
                    }
                }
            } catch (IOException e) {
                System.err.println("Lỗi xử lý client: " + e.getMessage());
            } finally {
                try {
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<h3>Synchronization - Khi threads "đánh nhau" nhau</h3>
<p>Đây là phần khó nhất của multithreading. Mình đã debug race conditions cả tuần liền.</p>
<p><strong>Race condition nightmare:</strong>
Mình có counter class, multiple threads increment cùng lúc. Kết quả? Final count sai hoàn toàn! Thread A đọc 5, thread B đọc 5, cả hai ghi 6. Thay vì 10, kết quả là 6.</p>
<p><strong>Synchronized - Simple solution:</strong></p>
<pre><code class="language-java">public class Counter {
    private int count = 0;
    
    public synchronized void increment() {
        count++; // Chỉ 1 thread có thể execute cùng lúc
    }
    
    public synchronized int getCount() {
        return count;
    }
}
</code></pre>
<p>Nhưng synchronized có vấn đề: performance kém, dễ deadlock. Mình học được ReentrantLock - flexible hơn.</p>
<pre><code class="language-java">import java.util.concurrent.locks.ReentrantLock;

public class SafeCounter {
    private int count = 0;
    private ReentrantLock lock = new ReentrantLock();
    
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock(); // Quan trọng: luôn unlock
        }
    }
}
</code></pre>
<p><strong>Deadlock horror story:</strong>
Mình từng tạo deadlock khi 2 threads chờ nhau. Thread A lock resource X, chờ Y; Thread B lock Y, chờ X. Kết quả: cả 2 treo forever.</p>
<p><strong>Bài học:</strong> Luôn acquire locks theo thứ tự nhất quán, avoid nested locks.</p>
<p><strong>Concurrent Collections - Thread-safe data structures:</strong>
Java có ConcurrentHashMap, CopyOnWriteArrayList - thread-safe mà performance tốt. Mình dùng chúng thay vì synchronized collections.</p>
<p>Từ khi học synchronization properly, multithreading bugs giảm hẳn. Nhưng vẫn cần cẩn thận - concurrency bugs khó debug lắm!</p>
<pre><code class="language-java">import java.util.concurrent.*;

public class ConcurrentCollectionsExample {
    public static void main(String[] args) {
        // ConcurrentHashMap - thread-safe HashMap
        ConcurrentHashMap&#x3C;String, Integer> map = new ConcurrentHashMap&#x3C;>();
        map.put("key1", 1);
        map.put("key2", 2);
        
        // BlockingQueue - thread-safe queue
        BlockingQueue&#x3C;String> queue = new LinkedBlockingQueue&#x3C;>();
        queue.offer("item1");
        queue.offer("item2");
        
        // CopyOnWriteArrayList - thread-safe ArrayList
        CopyOnWriteArrayList&#x3C;String> list = new CopyOnWriteArrayList&#x3C;>();
        list.add("element1");
        list.add("element2");
    }
}
</code></pre>
<h3>Future và Callable - Xử lý kết quả bất đồng bộ</h3>
<pre><code class="language-java">import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit Callable task
        Future&#x3C;String> future = executor.submit(() -> {
            Thread.sleep(2000);
            return "Kết quả từ thread";
        });
        
        System.out.println("Đang chờ kết quả...");
        
        try {
            // Lấy kết quả (blocking)
            String result = future.get(5, TimeUnit.SECONDS);
            System.out.println("Kết quả: " + result);
        } catch (TimeoutException e) {
            System.out.println("Timeout!");
        } catch (Exception e) {
            e.printStackTrace();
        }
        
        executor.shutdown();
    }
}
</code></pre>
<h3>CompletableFuture - Lập trình bất đồng bộ hiện đại</h3>
<pre><code class="language-java">import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {
    public static void main(String[] args) {
        CompletableFuture&#x3C;String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "Hello";
        });
        
        future.thenApply(s -> s + " World")
              .thenAccept(System.out::println);
        
        // Chờ hoàn thành
        future.join();
    }
}
</code></pre>
<h2>Những gì mình học được sau project multithreaded server</h2>
<p>Sau khi deploy server production và gặp đủ loại concurrency issues, mình rút ra nhiều bài học quý báu.</p>
<p><strong>Thread pool - Prevent OutOfMemory:</strong>
Mình từng tạo thread mới cho mỗi client. Với 1000 clients? 1000 threads! Server crash ngay. Thread pool cứu cánh - giới hạn số threads, tái sử dụng efficiently.</p>
<p><strong>Synchronization - Race conditions và deadlocks:</strong>
Mình debug race condition cả tuần. 2 threads modify shared data cùng lúc, kết quả unpredictable. Synchronization giúp, nhưng dễ tạo deadlock nếu không cẩn thận.</p>
<p><strong>Monitoring - Know your threads:</strong>
Production server cần metrics: active threads, queue size, response time. Mình implement monitoring để detect issues early.</p>
<p><strong>Performance vs Safety trade-off:</strong>
Synchronized methods safe nhưng slow. Concurrent collections fast hơn nhưng phức tạp hơn. Mình học được balance giữa 2 factors.</p>
<h2>Kết luận: Multithreading - Cầu nối từ single-threaded sang scalable systems</h2>
<p>Multithreading không chỉ là "chạy nhiều threads" - mà là cách scale applications để handle thousands of concurrent users. Từ single-threaded server chỉ handle 1 client, giờ mình có thể build systems phục vụ hàng triệu users.</p>
<p>Concurrency dạy mình: shared state nguy hiểm, isolation quan trọng, monitoring bắt buộc. Đây là foundation của high-performance Java applications.</p>
<p>Nếu bạn đang học Java và thấy multithreading confusing, đừng nản nhé! Mình cũng từng như bạn. Bắt đầu với simple Thread examples, rồi thread pools, synchronization. Practice nhiều, debug nhiều, bạn sẽ conquer được.</p>
<p><em>Lời khuyên cho sinh viên:</em></p>
<ul>
<li>Bắt đầu với basic Thread creation</li>
<li>Học thread pools trước khi synchronization</li>
<li>Debug race conditions bằng logging</li>
<li>Practice với concurrent collections</li>
</ul>
<p><em>P.S: Đây là kinh nghiệm mình học được trong môn Java nâng cao. Nếu bạn thấy bài viết hữu ích, hãy share cho bạn bè cùng học nhé!</em></p>
</div></article><div class="bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8"><div class="flex items-center justify-between flex-wrap gap-6"><div class="flex items-center gap-4"><div class="relative w-16 h-16 rounded-full overflow-hidden bg-gradient-to-br from-indigo-400 to-purple-500 flex-shrink-0"><img alt="Truong Yen Phuong" loading="lazy" decoding="async" data-nimg="fill" class="object-cover" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="/images/avatar/avatar.png"/></div><div><h3 class="font-semibold text-[#161513] text-lg mb-1">Truong Yen Phuong</h3><p class="text-sm text-gray-600">Tổng hợp kinh nghiệm</p></div></div><div class="flex items-center gap-4 flex-wrap"><div class="flex items-center gap-2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share2 lucide-share-2 w-5 h-5 text-[#b16cea]" aria-hidden="true"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" x2="15.42" y1="13.51" y2="17.49"></line><line x1="15.41" x2="8.59" y1="6.51" y2="10.49"></line></svg><span class="font-semibold text-[#161513]">Chia sẻ bài viết:</span></div><div class="flex items-center gap-2"><button type="button" class="social-link w-inline-block gradient" aria-label="Share on Facebook"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-facebook w-5 h-5" aria-hidden="true"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path></svg></div></div></button><button type="button" class="social-link w-inline-block gradient" aria-label="Share on X"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg></div></div></button><button type="button" class="social-link w-inline-block gradient" aria-label="Share on LinkedIn"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin w-5 h-5" aria-hidden="true"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></div></div></button><button type="button" class="social-link w-inline-block gradient" aria-label="Copy link"><div class="social-icon-wrapper" style="background-color:#f0f2f5"><div class="social-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-copy w-5 h-5" aria-hidden="true"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path></svg></div></div></button></div></div></div></div><div class="text-center"><a class="inline-flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-[#b16cea] to-[#ff5e69] text-white rounded-lg font-semibold hover:opacity-90 transition-opacity" href="/portfolio-blog/blog/"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left w-5 h-5" aria-hidden="true"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg>Xem tất cả bài viết</a></div></div></div><!--$--><!--/$--></main><footer class="footer bg-[#f0f2f5]"><div class="w-layout-blockcontainer container w-container"><div class="divider" style="background-color:rgb(22, 21, 19)"></div><div class="footer-wrap"><div class="flex footer-left"><a class="brand-logo " href="/portfolio-blog/"><span class="text-[30px] font-bold text-[#161513]">Fang.</span></a><div class="copyright dark" style="color:rgb(22, 21, 19)">© 2025 Designed by Truong Yen Phuong</div></div><div class="flex footer-right"><div class="nav-link-wrap"><a class="nav-link footer-link " style="color:rgb(22, 21, 19)" href="/portfolio-blog/">Trang chủ</a><a class="nav-link footer-link " style="color:rgb(22, 21, 19)" href="/portfolio-blog/certificates/">Chứng chỉ</a><a class="nav-link footer-link w--current" style="color:rgb(22, 21, 19)" href="/portfolio-blog/blog/">Bài viết</a><a class="nav-link footer-link " style="color:rgb(22, 21, 19)" href="/portfolio-blog/about/">Giới thiệu</a></div><div class="social-link-wrap"><a href="https://github.com/Pt-14" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></div></div></a><a href="https://www.linkedin.com/in/phuong-truong-yen-894359371/" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg></div></div></a><a href="https://x.com/itsnongfang" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path></svg></div></div></a><a href="https://www.facebook.com/phuong.yentruon" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"></path></svg></div></div></a><a href="https://www.instagram.com/heaven__fang/" target="_blank" rel="noopener noreferrer" class="social-link w-inline-block gradient"><div class="social-icon-wrapper"><div class="social-icon"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"></path></svg></div></div></a></div></div></div></div></footer><script src="/portfolio-blog/_next/static/chunks/4598cc32edf4e870.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[54731,[\"/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js\"],\"LanguageProvider\"]\n3:I[76055,[\"/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js\"],\"default\"]\n4:I[74919,[\"/portfolio-blog/_next/static/chunks/2ea5f535648d11e4.js\",\"/portfolio-blog/_next/static/chunks/9c7410708860575f.js\"],\"default\"]\n5:I[7882,[\"/portfolio-blog/_next/static/chunks/2ea5f535648d11e4.js\",\"/portfolio-blog/_next/static/chunks/9c7410708860575f.js\"],\"default\"]\n6:I[56450,[\"/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js\"],\"default\"]\n8:I[82321,[\"/portfolio-blog/_next/static/chunks/2ea5f535648d11e4.js\",\"/portfolio-blog/_next/static/chunks/9c7410708860575f.js\"],\"OutletBoundary\"]\n9:\"$Sreact.suspense\"\nb:I[82321,[\"/portfolio-blog/_next/static/chunks/2ea5f535648d11e4.js\",\"/portfolio-blog/_next/static/chunks/9c7410708860575f.js\"],\"ViewportBoundary\"]\nd:I[82321,[\"/portfolio-blog/_next/static/chunks/2ea5f535648d11e4.js\",\"/portfolio-blog/_next/static/chunks/9c7410708860575f.js\"],\"MetadataBoundary\"]\nf:I[23564,[],\"default\"]\n:HL[\"/portfolio-blog/_next/static/chunks/14299e94805ff3d3.css\",\"style\"]\n:HL[\"/portfolio-blog/_next/static/media/137e738a3044ae84-s.p.238dcd1b.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/portfolio-blog/_next/static/media/186c8edb2e53be7f-s.p.c99fd3fd.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/portfolio-blog/_next/static/media/83afe278b6a6bb3c-s.p.3a6ba036.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/portfolio-blog/_next/static/media/a3c73b24938559c3-s.p.bab49f4c.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/portfolio-blog/_next/static/media/fb30396e64817371-s.p.f046f548.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"FFLv47kkbcVThbBtn6b5h\",\"c\":[\"\",\"blog\",\"java-streams\",\"\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"java-streams\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/portfolio-blog/_next/static/chunks/14299e94805ff3d3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"vi\",\"className\":\"scroll-smooth\",\"children\":[\"$\",\"body\",null,{\"className\":\"bai_jamjuree_2f3e59e-module__uL3GvG__variable inter_5901b7c6-module__ec5Qua__variable font-sans antialiased bg-[#f0f2f5]\",\"children\":[\"$\",\"$L2\",null,{\"children\":[[\"$\",\"$L3\",null,{}],[\"$\",\"main\",null,{\"className\":\"min-h-screen\",\"children\":[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],[\"$\",\"$L6\",null,{}]]}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L4\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L5\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/portfolio-blog/_next/static/chunks/88ef56c00aa0fcf7.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$L8\",null,{\"children\":[\"$\",\"$9\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@a\"}]}]]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$Lb\",null,{\"children\":\"$Lc\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"$9\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Le\"}]}]}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:I[65645,[\"/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js\",\"/portfolio-blog/_next/static/chunks/88ef56c00aa0fcf7.js\"],\"\"]\n11:T3f35,"])</script><script>self.__next_f.push([1,"\u003ch2\u003eKhi server của mình bị \"đơ\" vì quá tải\u003c/h2\u003e\n\u003cp\u003eXin chào các bạn! Hôm nay mình muốn chia sẻ về hành trình học Multithreading trong Java. Đây là chủ đề mà lúc đầu mình thấy siêu khó hiểu, concurrency concepts phức tạp, race conditions, deadlocks - nghe đã muốn bỏ cuộc.\u003c/p\u003e\n\u003cp\u003eMình còn nhớ project đầu tiên: làm một simple chat server. Ban đầu dùng single thread, code đơn giản:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ewhile (true) {\n    Socket client = serverSocket.accept();\n    handleClient(client); // Xử lý từng client một\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNhưng khi test với 2-3 clients cùng lúc, ôi trời ơi! Server bị \"đơ\" cứng. Client thứ 2 phải chờ client thứ 1 gõ xong, send xong mới được phục vụ. Với 10 clients? Server lag muốn chết.\u003c/p\u003e\n\u003cp\u003eMình ngồi debug cả đêm, rồi học được multithreading. Wow! Từ single thread handle 1 client, giờ server có thể xử lý 1000+ clients đồng thời. Sự khác biệt như từ xe đạp lên ô tô vậy.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTại sao multithreading quan trọng trong network programming?\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMỗi client cần thread riêng (network I/O thường block)\u003c/li\u003e\n\u003cli\u003eServer phải responsive, không được \"đơ\" vì 1 client chậm\u003c/li\u003e\n\u003cli\u003eTận dụng multi-core CPU hiệu quả hơn\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eĐó là lúc mình hiểu: multithreading không chỉ là \"best practice\" - mà là bắt buộc cho server applications.\u003c/p\u003e\n\u003ch2\u003eHọc cách tạo thread - Từ confuse đến \"aha!\"\u003c/h2\u003e\n\u003cp\u003eLúc đầu học multithreading, mình confuse với Thread class và Runnable interface. \"Tại sao có 2 cách? Cách nào tốt hơn?\"\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCách 1: Extend Thread class\u003c/strong\u003e\nMình thử implement đầu tiên bằng cách extend Thread:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Hello from thread: \" + getName());\n        // Xử lý logic ở đây\n    }\n}\n\n// Sử dụng\nMyThread thread = new MyThread();\nthread.start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNhưng rồi mình học được: Java không support multiple inheritance. Nếu class đã extend class khác thì sao? Đó là lúc mình biết đến Runnable.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCách 2: Implement Runnable (mình dùng cách này)\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ClientHandler implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Handling client in thread: \" + Thread.currentThread().getName());\n        // Xử lý client logic\n    }\n}\n\n// Sử dụng\nThread thread = new Thread(new ClientHandler());\nthread.start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunnable flexible hơn vì có thể implement multiple interfaces. Bây giờ mình luôn dùng Runnable cho client handlers.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLambda với Runnable (Java 8+)\u003c/strong\u003e\nMình thích cách này nhất vì concise:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eThread thread = new Thread(() -\u003e {\n    System.out.println(\"Client handled by: \" + Thread.currentThread().getName());\n});\nthread.start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTừ khi học được Runnable, multithreading code của mình clean hẳn ra.\u003c/p\u003e\n\u003ch3\u003eThread là gì?\u003c/h3\u003e\n\u003cp\u003eThread (luồng) là đơn vị nhỏ nhất của việc thực thi trong một chương trình. Một chương trình Java có thể có nhiều threads chạy đồng thời, cho phép thực hiện nhiều tác vụ cùng lúc.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLợi ích của Multithreading:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTận dụng tối đa CPU (đặc biệt với multi-core processors)\u003c/li\u003e\n\u003cli\u003eCải thiện responsiveness của ứng dụng\u003c/li\u003e\n\u003cli\u003eXử lý nhiều client đồng thời trong network programming\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTạo Thread - Các cách cơ bản\u003c/h3\u003e\n\u003ch4\u003eCách 1: Extend Thread class\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread đang chạy: \" + Thread.currentThread().getName());\n        for (int i = 0; i \u0026#x3C; 5; i++) {\n            System.out.println(\"Count: \" + i);\n            try {\n                Thread.sleep(1000); // Ngủ 1 giây\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n    public static void main(String[] args) {\n        MyThread thread1 = new MyThread();\n        MyThread thread2 = new MyThread();\n        \n        thread1.start(); // Bắt đầu thread\n        thread2.start();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eCách 2: Implement Runnable interface (Khuyến nghị)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Thread đang chạy: \" + Thread.currentThread().getName());\n    }\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(new MyRunnable());\n        Thread thread2 = new Thread(new MyRunnable());\n        \n        thread1.start();\n        thread2.start();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003eCách 3: Lambda Expression (Java 8+)\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class LambdaThread {\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -\u003e {\n            System.out.println(\"Thread chạy với lambda: \" + \n                Thread.currentThread().getName());\n        });\n        thread.start();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eThread Pool - Bài học về resource management\u003c/h3\u003e\n\u003cp\u003eLúc đầu, mình tạo thread mới cho mỗi client. Với 100 clients? 100 threads! Mình thấy memory usage tăng vọt, CPU spike, rồi OutOfMemoryError.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThread Pool - Lifesaver:\u003c/strong\u003e\nMình học được ExecutorService - thread pool để tái sử dụng threads. Thay vì tạo/destroy threads liên tục, pool manage một số lượng threads cố định.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eExecutorService threadPool = Executors.newFixedThreadPool(10); // Max 10 threads\n\nfor (int i = 0; i \u0026#x3C; 100; i++) {\n    final int clientId = i;\n    threadPool.submit(() -\u003e {\n        System.out.println(\"Handling client \" + clientId + \n            \" on \" + Thread.currentThread().getName());\n        // Process client\n    });\n}\n\nthreadPool.shutdown(); // Đóng pool khi xong\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePerformance improvement:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTrước: 100 threads → memory issues\u003c/li\u003e\n\u003cli\u003eSau: 10 threads tái sử dụng → stable, efficient\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMình đã tối ưu server từ crash với 50 clients lên handle 1000+ clients smoothly.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNetwork server với thread pool:\u003c/strong\u003e\nTrong server thực tế, mình dùng thread pool cho tất cả client connections. Mỗi client được xử lý trong thread riêng từ pool, server không bao giờ overload.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.io.*;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class MultiThreadedServer {\n    private static final int PORT = 8080;\n    private static final int MAX_THREADS = 10;\n    private static ExecutorService threadPool = \n        Executors.newFixedThreadPool(MAX_THREADS);\n    \n    public static void main(String[] args) {\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            System.out.println(\"Server đang lắng nghe trên port \" + PORT);\n            \n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"Client kết nối: \" + \n                    clientSocket.getInetAddress());\n                \n                // Xử lý client trong thread pool\n                threadPool.submit(new ClientHandler(clientSocket));\n            }\n        } catch (IOException e) {\n            System.err.println(\"Lỗi server: \" + e.getMessage());\n        } finally {\n            threadPool.shutdown();\n        }\n    }\n    \n    // Inner class để xử lý từng client\n    static class ClientHandler implements Runnable {\n        private Socket clientSocket;\n        \n        public ClientHandler(Socket socket) {\n            this.clientSocket = socket;\n        }\n        \n        @Override\n        public void run() {\n            try (BufferedReader in = new BufferedReader(\n                    new InputStreamReader(clientSocket.getInputStream()));\n                 PrintWriter out = new PrintWriter(\n                    clientSocket.getOutputStream(), true)) {\n                \n                String inputLine;\n                while ((inputLine = in.readLine()) != null) {\n                    System.out.println(\"Thread \" + Thread.currentThread().getName() + \n                        \" nhận: \" + inputLine);\n                    \n                    // Xử lý message\n                    String response = \"Echo: \" + inputLine;\n                    out.println(response);\n                    \n                    if (\"quit\".equalsIgnoreCase(inputLine)) {\n                        break;\n                    }\n                }\n            } catch (IOException e) {\n                System.err.println(\"Lỗi xử lý client: \" + e.getMessage());\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eSynchronization - Khi threads \"đánh nhau\" nhau\u003c/h3\u003e\n\u003cp\u003eĐây là phần khó nhất của multithreading. Mình đã debug race conditions cả tuần liền.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRace condition nightmare:\u003c/strong\u003e\nMình có counter class, multiple threads increment cùng lúc. Kết quả? Final count sai hoàn toàn! Thread A đọc 5, thread B đọc 5, cả hai ghi 6. Thay vì 10, kết quả là 6.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSynchronized - Simple solution:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Counter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++; // Chỉ 1 thread có thể execute cùng lúc\n    }\n    \n    public synchronized int getCount() {\n        return count;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNhưng synchronized có vấn đề: performance kém, dễ deadlock. Mình học được ReentrantLock - flexible hơn.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.locks.ReentrantLock;\n\npublic class SafeCounter {\n    private int count = 0;\n    private ReentrantLock lock = new ReentrantLock();\n    \n    public void increment() {\n        lock.lock();\n        try {\n            count++;\n        } finally {\n            lock.unlock(); // Quan trọng: luôn unlock\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eDeadlock horror story:\u003c/strong\u003e\nMình từng tạo deadlock khi 2 threads chờ nhau. Thread A lock resource X, chờ Y; Thread B lock Y, chờ X. Kết quả: cả 2 treo forever.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBài học:\u003c/strong\u003e Luôn acquire locks theo thứ tự nhất quán, avoid nested locks.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConcurrent Collections - Thread-safe data structures:\u003c/strong\u003e\nJava có ConcurrentHashMap, CopyOnWriteArrayList - thread-safe mà performance tốt. Mình dùng chúng thay vì synchronized collections.\u003c/p\u003e\n\u003cp\u003eTừ khi học synchronization properly, multithreading bugs giảm hẳn. Nhưng vẫn cần cẩn thận - concurrency bugs khó debug lắm!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.*;\n\npublic class ConcurrentCollectionsExample {\n    public static void main(String[] args) {\n        // ConcurrentHashMap - thread-safe HashMap\n        ConcurrentHashMap\u0026#x3C;String, Integer\u003e map = new ConcurrentHashMap\u0026#x3C;\u003e();\n        map.put(\"key1\", 1);\n        map.put(\"key2\", 2);\n        \n        // BlockingQueue - thread-safe queue\n        BlockingQueue\u0026#x3C;String\u003e queue = new LinkedBlockingQueue\u0026#x3C;\u003e();\n        queue.offer(\"item1\");\n        queue.offer(\"item2\");\n        \n        // CopyOnWriteArrayList - thread-safe ArrayList\n        CopyOnWriteArrayList\u0026#x3C;String\u003e list = new CopyOnWriteArrayList\u0026#x3C;\u003e();\n        list.add(\"element1\");\n        list.add(\"element2\");\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eFuture và Callable - Xử lý kết quả bất đồng bộ\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.*;\n\npublic class FutureExample {\n    public static void main(String[] args) {\n        ExecutorService executor = Executors.newFixedThreadPool(3);\n        \n        // Submit Callable task\n        Future\u0026#x3C;String\u003e future = executor.submit(() -\u003e {\n            Thread.sleep(2000);\n            return \"Kết quả từ thread\";\n        });\n        \n        System.out.println(\"Đang chờ kết quả...\");\n        \n        try {\n            // Lấy kết quả (blocking)\n            String result = future.get(5, TimeUnit.SECONDS);\n            System.out.println(\"Kết quả: \" + result);\n        } catch (TimeoutException e) {\n            System.out.println(\"Timeout!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        \n        executor.shutdown();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eCompletableFuture - Lập trình bất đồng bộ hiện đại\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.util.concurrent.CompletableFuture;\n\npublic class CompletableFutureExample {\n    public static void main(String[] args) {\n        CompletableFuture\u0026#x3C;String\u003e future = CompletableFuture.supplyAsync(() -\u003e {\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"Hello\";\n        });\n        \n        future.thenApply(s -\u003e s + \" World\")\n              .thenAccept(System.out::println);\n        \n        // Chờ hoàn thành\n        future.join();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eNhững gì mình học được sau project multithreaded server\u003c/h2\u003e\n\u003cp\u003eSau khi deploy server production và gặp đủ loại concurrency issues, mình rút ra nhiều bài học quý báu.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThread pool - Prevent OutOfMemory:\u003c/strong\u003e\nMình từng tạo thread mới cho mỗi client. Với 1000 clients? 1000 threads! Server crash ngay. Thread pool cứu cánh - giới hạn số threads, tái sử dụng efficiently.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSynchronization - Race conditions và deadlocks:\u003c/strong\u003e\nMình debug race condition cả tuần. 2 threads modify shared data cùng lúc, kết quả unpredictable. Synchronization giúp, nhưng dễ tạo deadlock nếu không cẩn thận.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMonitoring - Know your threads:\u003c/strong\u003e\nProduction server cần metrics: active threads, queue size, response time. Mình implement monitoring để detect issues early.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePerformance vs Safety trade-off:\u003c/strong\u003e\nSynchronized methods safe nhưng slow. Concurrent collections fast hơn nhưng phức tạp hơn. Mình học được balance giữa 2 factors.\u003c/p\u003e\n\u003ch2\u003eKết luận: Multithreading - Cầu nối từ single-threaded sang scalable systems\u003c/h2\u003e\n\u003cp\u003eMultithreading không chỉ là \"chạy nhiều threads\" - mà là cách scale applications để handle thousands of concurrent users. Từ single-threaded server chỉ handle 1 client, giờ mình có thể build systems phục vụ hàng triệu users.\u003c/p\u003e\n\u003cp\u003eConcurrency dạy mình: shared state nguy hiểm, isolation quan trọng, monitoring bắt buộc. Đây là foundation của high-performance Java applications.\u003c/p\u003e\n\u003cp\u003eNếu bạn đang học Java và thấy multithreading confusing, đừng nản nhé! Mình cũng từng như bạn. Bắt đầu với simple Thread examples, rồi thread pools, synchronization. Practice nhiều, debug nhiều, bạn sẽ conquer được.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLời khuyên cho sinh viên:\u003c/em\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBắt đầu với basic Thread creation\u003c/li\u003e\n\u003cli\u003eHọc thread pools trước khi synchronization\u003c/li\u003e\n\u003cli\u003eDebug race conditions bằng logging\u003c/li\u003e\n\u003cli\u003ePractice với concurrent collections\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eP.S: Đây là kinh nghiệm mình học được trong môn Java nâng cao. Nếu bạn thấy bài viết hữu ích, hãy share cho bạn bè cùng học nhé!\u003c/em\u003e\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"div\",null,{\"className\":\"pt-16 min-h-screen bg-[#f0f2f5]\",\"children\":[\"$\",\"div\",null,{\"className\":\"max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12\",\"children\":[[\"$\",\"$L10\",null,{\"href\":\"/blog\",\"className\":\"inline-flex items-center gap-2 text-[#b16cea] hover:text-[#ff5e69] mb-8 transition-colors font-medium\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left w-5 h-5\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],[\"$\",\"span\",null,{\"children\":\"Quay lại Blog\"}]]}],[\"$\",\"div\",null,{\"className\":\"bg-white rounded-xl shadow-sm border border-gray-200 p-8 md:p-12 mb-8\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl md:text-5xl font-bold text-[#161513] mb-4 leading-tight\",\"children\":\"Đa tuyến và Xử lý đồng thời trong Java\"}],[\"$\",\"p\",null,{\"className\":\"text-lg text-gray-600 leading-relaxed mb-6\",\"children\":\"Tìm hiểu về Multithreading và Concurrency trong Java - cách tạo và quản lý threads, xử lý nhiều client đồng thời trong lập trình mạng.\"}],[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between flex-wrap gap-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2\",\"children\":[[\"$\",\"span\",\"Java\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Java\"}],[\"$\",\"span\",\"Multithreading\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Multithreading\"}],[\"$\",\"span\",\"Concurrency\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Concurrency\"}],[\"$\",\"span\",\"Threads\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"Threads\"}],[\"$\",\"span\",\"ExecutorService\",{\"className\":\"px-3 py-1.5 bg-gray-100 text-gray-700 rounded-full text-sm font-medium\",\"children\":\"ExecutorService\"}]]}],[\"$\",\"span\",null,{\"className\":\"text-sm text-gray-500 whitespace-nowrap\",\"style\":{\"fontFamily\":\"var(--font-inter)\"},\"children\":\"2024-04-05\"}]]}]]}],[\"$\",\"article\",null,{\"className\":\"mb-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"prose prose-lg max-w-none prose-headings:text-[#161513] prose-p:text-[#374151] prose-p:leading-relaxed prose-a:text-[#b16cea] prose-a:no-underline hover:prose-a:underline prose-strong:text-[#161513] prose-code:text-[#b16cea] prose-code:bg-gray-100 prose-code:px-1.5 prose-code:py-0.5 prose-code:rounded prose-code:text-sm prose-pre:bg-[#1f2937] prose-pre:rounded-lg prose-h2:text-2xl prose-h2:font-bold prose-h2:mt-12 prose-h2:mb-6 prose-h3:text-xl prose-h3:font-semibold prose-h3:mt-8 prose-h3:mb-4\",\"dangerouslySetInnerHTML\":{\"__html\":\"$11\"}}]}],\"$L12\",\"$L13\"]}]}]\n"])</script><script>self.__next_f.push([1,"14:I[43465,[\"/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js\",\"/portfolio-blog/_next/static/chunks/88ef56c00aa0fcf7.js\"],\"Image\"]\n15:I[32771,[\"/portfolio-blog/_next/static/chunks/3b0f1a99fc7a519e.js\",\"/portfolio-blog/_next/static/chunks/88ef56c00aa0fcf7.js\"],\"default\"]\n"])</script><script>self.__next_f.push([1,"12:[\"$\",\"div\",null,{\"className\":\"bg-white rounded-xl shadow-sm border border-gray-200 p-6 mb-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between flex-wrap gap-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"relative w-16 h-16 rounded-full overflow-hidden bg-gradient-to-br from-indigo-400 to-purple-500 flex-shrink-0\",\"children\":[\"$\",\"$L14\",null,{\"src\":\"/images/avatar/avatar.png\",\"alt\":\"Truong Yen Phuong\",\"fill\":true,\"className\":\"object-cover\"}]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"h3\",null,{\"className\":\"font-semibold text-[#161513] text-lg mb-1\",\"children\":\"Truong Yen Phuong\"}],[\"$\",\"p\",null,{\"className\":\"text-sm text-gray-600\",\"children\":\"Tổng hợp kinh nghiệm\"}]]}]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4 flex-wrap\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-2\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-share2 lucide-share-2 w-5 h-5 text-[#b16cea]\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"circle\",\"gq8acd\",{\"cx\":\"18\",\"cy\":\"5\",\"r\":\"3\"}],[\"$\",\"circle\",\"w7nqdw\",{\"cx\":\"6\",\"cy\":\"12\",\"r\":\"3\"}],[\"$\",\"circle\",\"1xt0gg\",{\"cx\":\"18\",\"cy\":\"19\",\"r\":\"3\"}],[\"$\",\"line\",\"47mynk\",{\"x1\":\"8.59\",\"x2\":\"15.42\",\"y1\":\"13.51\",\"y2\":\"17.49\"}],[\"$\",\"line\",\"1n3mei\",{\"x1\":\"15.41\",\"x2\":\"8.59\",\"y1\":\"6.51\",\"y2\":\"10.49\"}],\"$undefined\"]}],[\"$\",\"span\",null,{\"className\":\"font-semibold text-[#161513]\",\"children\":\"Chia sẻ bài viết:\"}]]}],[\"$\",\"$L15\",null,{\"title\":\"Đa tuyến và Xử lý đồng thời trong Java\",\"slug\":\"java-streams\"}]]}]]}]}]\n"])</script><script>self.__next_f.push([1,"13:[\"$\",\"div\",null,{\"className\":\"text-center\",\"children\":[\"$\",\"$L10\",null,{\"href\":\"/blog\",\"className\":\"inline-flex items-center gap-2 px-8 py-3 bg-gradient-to-r from-[#b16cea] to-[#ff5e69] text-white rounded-lg font-semibold hover:opacity-90 transition-opacity\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left w-5 h-5\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],\"Xem tất cả bài viết\"]}]}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"16:I[93592,[\"/portfolio-blog/_next/static/chunks/2ea5f535648d11e4.js\",\"/portfolio-blog/_next/static/chunks/9c7410708860575f.js\"],\"IconMark\"]\na:null\ne:[[\"$\",\"title\",\"0\",{\"children\":\"Đa tuyến và Xử lý đồng thời trong Java - Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Tìm hiểu về Multithreading và Concurrency trong Java - cách tạo và quản lý threads, xử lý nhiều client đồng thời trong lập trình mạng.\"}],[\"$\",\"meta\",\"2\",{\"name\":\"author\",\"content\":\"Fang\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"Frontend Developer,UI/UX Designer,React,Next.js,JavaScript,Java,Portfolio\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Truong Yen Phuong | Portfolio\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"Portfolio và Blog cá nhân về Frontend Development và UI/UX Design\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:type\",\"content\":\"website\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Truong Yen Phuong | Portfolio\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"Portfolio và Blog cá nhân về Frontend Development và UI/UX Design\"}],[\"$\",\"link\",\"10\",{\"rel\":\"icon\",\"href\":\"/portfolio-blog/favicon.ico?favicon.3546e4df.ico\",\"sizes\":\"454x454\",\"type\":\"image/x-icon\"}],[\"$\",\"$L16\",\"11\",{}]]\n"])</script></body></html>